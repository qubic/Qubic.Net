using System.Text;
using Qubic.ContractGen.Parsing;

namespace Qubic.ContractGen.Generation;

public class CSharpEmitter
{
    private readonly StringBuilder _sb = new();
    private int _indent;

    public string Emit(ContractDefinition contract)
    {
        _sb.Clear();
        _indent = 0;

        EmitHeader(contract);
        EmitUsings();
        Line();
        Line($"namespace Qubic.Core.Contracts.{contract.CSharpName};");
        Line();

        EmitContractClass(contract);

        // Emit function types
        foreach (var func in contract.Functions)
        {
            EmitFunctionTypes(contract, func);
        }

        // Emit procedure types
        foreach (var proc in contract.Procedures)
        {
            EmitProcedureTypes(contract, proc);
        }

        return _sb.ToString();
    }

    private void EmitHeader(ContractDefinition contract)
    {
        Line("// <auto-generated>");
        Line($"// Generated by Qubic.ContractGen from {contract.HeaderFile}.");
        Line("// Do not edit manually. Re-run the generator after updating deps/qubic-core.");
        Line("// </auto-generated>");
        Line();
    }

    private void EmitUsings()
    {
        Line("using System.Buffers.Binary;");
        Line("using Qubic.Core.Contracts;");
        Line("using Qubic.Core.Payloads;");
    }

    private void EmitContractClass(ContractDefinition contract)
    {
        Line($"/// <summary>{contract.CSharpName} contract (index {contract.ContractIndex}).</summary>");
        Line($"public static class {contract.CSharpName}Contract");
        Line("{");
        _indent++;

        Line($"/// <summary>Contract index on the Qubic network.</summary>");
        Line($"public const int ContractIndex = {contract.ContractIndex};");
        Line();
        Line($"/// <summary>Gets the 32-byte contract public key.</summary>");
        Line($"public static byte[] GetPublicKey() => QubicContracts.GetContractPublicKey(ContractIndex);");

        if (contract.Functions.Count > 0)
        {
            Line();
            Line("/// <summary>Read-only query function IDs.</summary>");
            Line("public static class Functions");
            Line("{");
            _indent++;
            foreach (var func in contract.Functions)
            {
                Line($"/// <summary>{func.Name} (inputType={func.InputType}).</summary>");
                Line($"public const uint {ToPascalCase(func.Name)} = {func.InputType};");
            }
            _indent--;
            Line("}");
        }

        if (contract.Procedures.Count > 0)
        {
            Line();
            Line("/// <summary>State-mutating procedure IDs.</summary>");
            Line("public static class Procedures");
            Line("{");
            _indent++;
            foreach (var proc in contract.Procedures)
            {
                Line($"/// <summary>{proc.Name} (inputType={proc.InputType}).</summary>");
                Line($"public const uint {ToPascalCase(proc.Name)} = {proc.InputType};");
            }
            _indent--;
            Line("}");
        }

        _indent--;
        Line("}");
    }

    private void EmitFunctionTypes(ContractDefinition contract, FunctionDef func)
    {
        var name = ToPascalCase(func.Name);

        Line();
        EmitSeparator($"Function: {func.Name} (inputType={func.InputType})");

        // Emit nested structs from output first
        EmitNestedStructs(func.Output, name);

        // Emit input struct
        EmitInputStruct($"{name}Input", func.Input, isPayload: false, inputType: 0);

        // Emit output struct
        EmitOutputStruct($"{name}Output", func.Output, name);
    }

    private void EmitProcedureTypes(ContractDefinition contract, ProcedureDef proc)
    {
        var name = ToPascalCase(proc.Name);

        Line();
        EmitSeparator($"Procedure: {proc.Name} (inputType={proc.InputType})");

        // Emit nested structs from output first
        EmitNestedStructs(proc.Output, name);

        // Emit input as ITransactionPayload
        EmitInputStruct($"{name}Payload", proc.Input, isPayload: true, inputType: proc.InputType);

        // Emit output struct
        EmitOutputStruct($"{name}Output", proc.Output, name);
    }

    private void EmitNestedStructs(StructDef structDef, string parentName)
    {
        foreach (var nested in structDef.NestedStructs)
        {
            var structName = $"{parentName}{ToPascalCase(nested.CppName)}";
            var size = ComputeStructSize(nested);
            Line();
            Line($"/// <summary>Nested type from {parentName}.</summary>");
            Line($"public readonly struct {structName}");
            Line("{");
            _indent++;
            Line($"public const int Size = {size};");
            Line();

            EmitProperties(nested);
            Line();
            EmitReadFromMethod(structName, nested);

            _indent--;
            Line("}");
        }
    }

    private void EmitInputStruct(string structName, StructDef def, bool isPayload, int inputType)
    {
        var size = ComputeStructSize(def);
        Line();

        if (def.IsEmpty)
        {
            if (isPayload)
            {
                Line($"/// <summary>Input for procedure (empty payload).</summary>");
                Line($"public sealed class {structName} : ITransactionPayload, ISmartContractInput");
                Line("{");
                _indent++;
                Line($"public ushort InputType => {inputType};");
                Line($"public ushort InputSize => 0;");
                Line($"public int SerializedSize => 0;");
                Line($"public byte[] GetPayloadBytes() => [];");
                Line($"public byte[] ToBytes() => [];");
                _indent--;
                Line("}");
            }
            else
            {
                Line($"/// <summary>Input for query (empty).</summary>");
                Line($"public readonly struct {structName} : ISmartContractInput");
                Line("{");
                _indent++;
                Line($"public int SerializedSize => 0;");
                Line($"public byte[] ToBytes() => [];");
                _indent--;
                Line("}");
            }
            return;
        }

        if (isPayload)
        {
            Line($"/// <summary>Input payload for procedure.</summary>");
            Line($"public sealed class {structName} : ITransactionPayload, ISmartContractInput");
            Line("{");
            _indent++;
            Line($"public const int Size = {size};");
            Line();
            Line($"public ushort InputType => {inputType};");
            Line($"public ushort InputSize => Size;");
            Line($"public int SerializedSize => Size;");
            Line();
            EmitProperties(def);
            Line();
            Line($"public byte[] GetPayloadBytes() => ToBytes();");
            Line();
            EmitToBytesMethod(def, size);
        }
        else
        {
            Line($"/// <summary>Input for query.</summary>");
            Line($"public readonly struct {structName} : ISmartContractInput");
            Line("{");
            _indent++;
            Line($"public const int Size = {size};");
            Line();
            Line($"public int SerializedSize => Size;");
            Line();
            EmitProperties(def);
            Line();
            EmitToBytesMethod(def, size);
        }

        _indent--;
        Line("}");
    }

    private void EmitOutputStruct(string structName, StructDef def, string parentName)
    {
        Line();
        if (def.IsEmpty)
        {
            Line($"/// <summary>Output (empty).</summary>");
            Line($"public readonly struct {structName} : ISmartContractOutput<{structName}>");
            Line("{");
            _indent++;
            Line($"public static {structName} FromBytes(ReadOnlySpan<byte> data) => new();");
            _indent--;
            Line("}");
            return;
        }

        var size = ComputeStructSize(def);
        Line($"/// <summary>Output.</summary>");
        Line($"public readonly struct {structName} : ISmartContractOutput<{structName}>");
        Line("{");
        _indent++;

        EmitOutputProperties(def, parentName);
        Line();
        EmitFromBytesMethod(structName, def, parentName);

        _indent--;
        Line("}");
    }

    private void EmitProperties(StructDef def)
    {
        foreach (var field in def.Fields)
        {
            var propName = ToPascalCase(field.Name);
            var csType = GetCSharpPropertyType(field);

            if (HasRequiredInit(field))
                Line($"public required {csType} {propName} {{ get; init; }}");
            else
                Line($"public {csType} {propName} {{ get; init; }}");
        }
    }

    private void EmitOutputProperties(StructDef def, string parentName)
    {
        foreach (var field in def.Fields)
        {
            var propName = ToPascalCase(field.Name);
            var csType = GetCSharpOutputPropertyType(field, parentName, def);
            Line($"public {csType} {propName} {{ get; init; }}");
        }
    }

    private void EmitToBytesMethod(StructDef def, int totalSize)
    {
        var fieldOffsets = ComputeFieldOffsets(def, out _, out _);

        Line($"public byte[] ToBytes()");
        Line("{");
        _indent++;
        Line($"var bytes = new byte[Size];");

        for (int fi = 0; fi < def.Fields.Count; fi++)
        {
            var field = def.Fields[fi];
            var offset = fieldOffsets[fi];
            var propName = ToPascalCase(field.Name);

            if (field.IsArray)
            {
                var elemSize = GetTypeSize(field.ArrayElementType ?? field.CppType);
                if (TypeMapper.IsPrimitive(field.ArrayElementType ?? field.CppType))
                {
                    Line($"for (int i = 0; i < {field.ArrayLength} && {propName} != null && i < {propName}.Length; i++)");
                    Line("{");
                    _indent++;
                    var writeStmt = TypeMapper.GetWriteStatement(
                        field.ArrayElementType ?? field.CppType,
                        $"bytes.AsSpan({offset} + i * {elemSize})",
                        $"{propName}[i]");
                    Line(writeStmt);
                    _indent--;
                    Line("}");
                }
                else
                {
                    // Nested struct array - skip for now, just advance offset
                    Line($"// Array<{field.ArrayElementType}, {field.ArrayLength}> - {propName}");
                    Line($"// TODO: serialize nested struct array");
                }
            }
            else if (TypeMapper.IsPrimitive(field.CppType))
            {
                var size = GetTypeSize(field.CppType);
                var spanExpr = size == 1
                    ? $"bytes.AsSpan({offset}, 1)"
                    : $"bytes.AsSpan({offset})";
                Line(TypeMapper.GetWriteStatement(field.CppType, spanExpr, propName));
            }
            else
            {
                // Unknown struct type - skip (size unknown)
                Line($"// TODO: serialize unknown type {field.CppType} for {propName}");
            }
        }

        Line("return bytes;");
        _indent--;
        Line("}");
    }

    private void EmitFromBytesMethod(string structName, StructDef def, string parentName)
    {
        var fieldOffsets = ComputeFieldOffsets(def, out _, out _);

        Line($"public static {structName} FromBytes(ReadOnlySpan<byte> data)");
        Line("{");
        _indent++;

        var assignments = new List<string>();

        for (int fi = 0; fi < def.Fields.Count; fi++)
        {
            var field = def.Fields[fi];
            var offset = fieldOffsets[fi];
            var propName = ToPascalCase(field.Name);

            if (field.IsArray)
            {
                var elemType = field.ArrayElementType ?? field.CppType;
                var elemSize = GetTypeSize(elemType);
                var csElemType = GetCSharpArrayElementType(field, parentName, def);

                if (TypeMapper.IsPrimitive(elemType))
                {
                    Line($"var {CamelCase(field.Name)} = {NewArrayExpr(csElemType, field.ArrayLength)};");
                    Line($"for (int i = 0; i < {field.ArrayLength}; i++)");
                    Line("{");
                    _indent++;
                    var readExpr = TypeMapper.GetReadExpression(elemType,
                        elemSize == 1
                            ? $"data.Slice({offset} + i * {elemSize}, {elemSize})"
                            : $"data[({offset} + i * {elemSize})..]");
                    Line($"{CamelCase(field.Name)}[i] = {readExpr};");
                    _indent--;
                    Line("}");
                    assignments.Add($"{propName} = {CamelCase(field.Name)}");
                }
                else if (IsKnownNestedStruct(elemType, def))
                {
                    var nestedTypeName = $"{parentName}{ToPascalCase(elemType)}";
                    Line($"var {CamelCase(field.Name)} = new {nestedTypeName}[{field.ArrayLength}];");
                    Line($"for (int i = 0; i < {field.ArrayLength}; i++)");
                    Line("{");
                    _indent++;
                    Line($"{CamelCase(field.Name)}[i] = {nestedTypeName}.ReadFrom(data.Slice({offset} + i * {nestedTypeName}.Size, {nestedTypeName}.Size));");
                    _indent--;
                    Line("}");
                    assignments.Add($"{propName} = {CamelCase(field.Name)}");
                }
                else
                {
                    // Unknown nested struct array - copy raw bytes
                    var totalBytes = elemSize > 0 ? elemSize * field.ArrayLength : 0;
                    if (totalBytes > 0)
                    {
                        assignments.Add($"{propName} = data.Slice({offset}, {totalBytes}).ToArray()");
                    }
                    else
                    {
                        assignments.Add($"{propName} = [] /* unknown struct array {elemType} */");
                    }
                }
            }
            else if (TypeMapper.IsPrimitive(field.CppType))
            {
                var size = GetTypeSize(field.CppType);
                var spanSlice = size == 1
                    ? $"data.Slice({offset}, 1)"
                    : $"data[{offset}..]";
                var readExpr = TypeMapper.GetReadExpression(field.CppType, spanSlice);
                assignments.Add($"{propName} = {readExpr}");
            }
            else
            {
                // Unknown struct field - skip with zero offset (we don't know the size)
                assignments.Add($"{propName} = [] /* unknown type {field.CppType} */");
            }
        }

        Line($"return new {structName}");
        Line("{");
        _indent++;
        for (int i = 0; i < assignments.Count; i++)
        {
            var comma = i < assignments.Count - 1 ? "," : "";
            Line($"{assignments[i]}{comma}");
        }
        _indent--;
        Line("};");

        _indent--;
        Line("}");
    }

    private void EmitReadFromMethod(string structName, StructDef def)
    {
        var fieldOffsets = ComputeFieldOffsets(def, out _, out _);

        Line($"public static {structName} ReadFrom(ReadOnlySpan<byte> data)");
        Line("{");
        _indent++;

        var assignments = new List<string>();

        for (int fi = 0; fi < def.Fields.Count; fi++)
        {
            var field = def.Fields[fi];
            var offset = fieldOffsets[fi];
            var propName = ToPascalCase(field.Name);

            if (field.IsArray)
            {
                var elemType = field.ArrayElementType ?? field.CppType;
                var elemSize = GetTypeSize(elemType);

                if (TypeMapper.IsPrimitive(elemType))
                {
                    var csElemType = TypeMapper.GetCSharpType(elemType);
                    Line($"var {CamelCase(field.Name)} = {NewArrayExpr(csElemType, field.ArrayLength)};");
                    Line($"for (int i = 0; i < {field.ArrayLength}; i++)");
                    Line("{");
                    _indent++;
                    var readExpr = TypeMapper.GetReadExpression(elemType,
                        elemSize == 1
                            ? $"data.Slice({offset} + i * {elemSize}, {elemSize})"
                            : $"data[({offset} + i * {elemSize})..]");
                    Line($"{CamelCase(field.Name)}[i] = {readExpr};");
                    _indent--;
                    Line("}");
                    assignments.Add($"{propName} = {CamelCase(field.Name)}");
                }
                else
                {
                    // Unknown struct array in nested struct - raw bytes fallback
                    var totalBytes = elemSize > 0 ? elemSize * field.ArrayLength : 0;
                    if (totalBytes > 0)
                        assignments.Add($"{propName} = data.Slice({offset}, {totalBytes}).ToArray()");
                    else
                        assignments.Add($"{propName} = []");
                }
            }
            else
            {
                var size = GetTypeSize(field.CppType);
                var spanSlice = size == 1
                    ? $"data.Slice({offset}, 1)"
                    : $"data[{offset}..]";
                var readExpr = TypeMapper.GetReadExpression(field.CppType, spanSlice);
                assignments.Add($"{propName} = {readExpr}");
            }
        }

        Line($"return new {structName}");
        Line("{");
        _indent++;
        for (int i = 0; i < assignments.Count; i++)
        {
            var comma = i < assignments.Count - 1 ? "," : "";
            Line($"{assignments[i]}{comma}");
        }
        _indent--;
        Line("};");

        _indent--;
        Line("}");
    }

    private void EmitSeparator(string title)
    {
        Line($"// ═══ {title} ═══");
    }

    private string GetCSharpPropertyType(FieldDef field)
    {
        if (field.IsArray)
        {
            var elemType = field.ArrayElementType ?? field.CppType;
            if (TypeMapper.IsPrimitive(elemType))
                return $"{TypeMapper.GetCSharpType(elemType)}[]";
            // Unknown nested struct element type - use byte[] for raw bytes
            return "byte[]";
        }
        if (TypeMapper.IsPrimitive(field.CppType))
            return TypeMapper.GetCSharpType(field.CppType);
        // Unknown struct type - use byte[] for raw bytes
        return "byte[]";
    }

    private string GetCSharpOutputPropertyType(FieldDef field, string parentName, StructDef def)
    {
        if (field.IsArray)
        {
            var elemType = field.ArrayElementType ?? field.CppType;
            if (TypeMapper.IsPrimitive(elemType))
                return $"{TypeMapper.GetCSharpType(elemType)}[]";
            if (IsKnownNestedStruct(elemType, def))
                return $"{parentName}{ToPascalCase(elemType)}[]";
            // Unknown nested struct element type - use byte[] for raw bytes
            return "byte[]";
        }
        if (TypeMapper.IsPrimitive(field.CppType))
            return TypeMapper.GetCSharpType(field.CppType);
        // Unknown struct type - use byte[] for raw bytes
        return "byte[]";
    }

    private string GetCSharpArrayElementType(FieldDef field, string parentName, StructDef def)
    {
        var elemType = field.ArrayElementType ?? field.CppType;
        if (TypeMapper.IsPrimitive(elemType))
            return TypeMapper.GetCSharpType(elemType);
        if (IsKnownNestedStruct(elemType, def))
            return $"{parentName}{ToPascalCase(elemType)}";
        // Unknown - treat as byte
        return "byte";
    }

    private bool IsKnownNestedStruct(string cppType, StructDef parentDef)
    {
        return parentDef.NestedStructs.Any(n => n.CppName == cppType);
    }

    /// <summary>
    /// Generates correct C# array creation expression, handling jagged arrays.
    /// e.g. NewArrayExpr("byte[]", 5) => "new byte[5][]" (not "new byte[][5]")
    /// </summary>
    private static string NewArrayExpr(string elemType, int count)
    {
        if (elemType.EndsWith("[]"))
        {
            var baseType = elemType[..^2];
            return $"new {baseType}[{count}][]";
        }
        return $"new {elemType}[{count}]";
    }

    private int GetTypeSize(string cppType)
    {
        var size = TypeMapper.GetPrimitiveSize(cppType);
        if (size > 0) return size;
        // For nested structs, we'd need to look up the size - return 0 as fallback
        return 0;
    }

    private int GetTypeAlignment(string cppType)
    {
        return TypeMapper.GetPrimitiveAlignment(cppType);
    }

    /// <summary>Round up to the next multiple of alignment.</summary>
    private static int AlignUp(int value, int alignment)
    {
        if (alignment <= 1) return value;
        return (value + alignment - 1) / alignment * alignment;
    }

    /// <summary>
    /// Compute field offsets with C++ alignment rules (MSVC default /Zp8).
    /// Each field is aligned to its natural alignment, and the struct size
    /// is padded to a multiple of the struct's max member alignment.
    /// </summary>
    private List<int> ComputeFieldOffsets(StructDef def, out int totalSize, out int structAlignment)
    {
        var offsets = new List<int>();
        int offset = 0;
        int maxAlign = 1;

        foreach (var field in def.Fields)
        {
            int fieldAlign;
            int fieldSize;

            if (field.IsArray)
            {
                var elemType = field.ArrayElementType ?? field.CppType;
                var elemSize = GetTypeSize(elemType);
                // Array alignment = element alignment
                fieldAlign = TypeMapper.IsPrimitive(elemType) ? GetTypeAlignment(elemType) : 1;

                if (elemSize == 0 && field.NestedStructTypeName != null)
                {
                    var nestedDef = def.NestedStructs.FirstOrDefault(n => n.CppName == field.NestedStructTypeName);
                    if (nestedDef != null)
                    {
                        ComputeFieldOffsets(nestedDef, out var nestedSize, out var nestedAlign);
                        elemSize = nestedSize;
                        fieldAlign = nestedAlign;
                    }
                }

                fieldSize = elemSize * field.ArrayLength;
            }
            else
            {
                fieldSize = GetTypeSize(field.CppType);
                fieldAlign = TypeMapper.IsPrimitive(field.CppType) ? GetTypeAlignment(field.CppType) : 1;
            }

            // Align the offset for this field
            offset = AlignUp(offset, fieldAlign);
            offsets.Add(offset);
            offset += fieldSize;

            if (fieldAlign > maxAlign) maxAlign = fieldAlign;
        }

        // Pad struct to alignment boundary (required for arrays of this struct)
        structAlignment = maxAlign;
        totalSize = AlignUp(offset, maxAlign);
        return offsets;
    }

    private int ComputeStructSize(StructDef def)
    {
        ComputeFieldOffsets(def, out var totalSize, out _);
        return totalSize;
    }

    private bool HasRequiredInit(FieldDef field)
    {
        // byte[] (id) and arrays should be required
        if (field.CppType is "id" or "m256i" or "Asset") return true;
        if (field.IsArray) return false; // arrays default to null
        return false;
    }

    private void Line(string text = "")
    {
        if (string.IsNullOrEmpty(text))
            _sb.AppendLine();
        else
            _sb.AppendLine($"{new string(' ', _indent * 4)}{text}");
    }

    public static string ToPascalCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;

        // If already PascalCase or all caps, just ensure first char is upper
        if (char.IsUpper(name[0])) return name;

        // camelCase -> PascalCase
        return char.ToUpper(name[0]) + name[1..];
    }

    private static string CamelCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;
        if (char.IsLower(name[0])) return name;
        return char.ToLower(name[0]) + name[1..];
    }
}
