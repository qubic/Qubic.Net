@inherits LayoutComponentBase
@implements IDisposable
@inject QubicBackendService Backend
@inject QubicSettingsService Settings
@inject SeedSessionService Seed
@inject TickMonitorService TickMonitor
@inject TransactionTrackerService TxTracker
@inject Qubic.Services.Storage.WalletStorageService WalletStorage
@inject PeerAutoDiscoverService PeerAutoDiscover
@inject LabelService Labels
@inject QubicStaticService StaticData

<div class="d-flex flex-column vh-100">
    <nav class="navbar navbar-dark bg-dark px-3">
        <a class="navbar-brand mb-0 h1" href="/">
            <img src="qubic-logo.svg" alt="Qubic" />
            <span>Toolkit</span>
        </a>
        <div class="d-flex align-items-center gap-2">
            @if (Seed.HasSeed)
            {
                <span class="badge bg-danger">Seed active</span>
                <span class="badge bg-secondary mono small">@Seed.Identity?.ToString()[..12]...</span>
                <button class="btn btn-sm btn-outline-light" @onclick="ClearSeed">Clear</button>
            }
            else
            {
                <input type="password" class="form-control form-control-sm bg-dark text-light border-secondary"
                       style="width:280px" placeholder="Enter 55-char seed to enable signing..."
                       @bind="_seedInput" @bind:event="oninput" />
                <button class="btn btn-sm btn-outline-success" @onclick="SetSeed"
                        disabled="@(_seedInput?.Length != 55)">Unlock</button>
            }
            <span class="text-secondary mx-1">|</span>
            <select class="form-select form-select-sm bg-dark text-light border-secondary" style="width:auto"
                    @bind="Backend.ActiveBackend" @bind:after="OnBackendChanged">
                <option value="@QueryBackend.Rpc">RPC</option>
                <option value="@QueryBackend.Bob">Bob</option>
                <option value="@QueryBackend.DirectNetwork">Direct Network</option>
            </select>
            @if (Backend.ActiveBackend == QueryBackend.DirectNetwork)
            {
                <input class="form-control form-control-sm bg-dark text-light border-secondary" style="width:160px"
                       placeholder="Host" @bind="Backend.NodeHost" @bind:event="oninput" />
                <input type="number" class="form-control form-control-sm bg-dark text-light border-secondary" style="width:70px"
                       placeholder="Port" @bind="Backend.NodePort" />
                <button class="btn btn-sm btn-outline-warning" @onclick="AutoDiscover"
                        disabled="@_discovering" title="Auto-discover a recent peer">
                    @if (_discovering)
                    {
                        <i class="bi bi-arrow-repeat spin"></i>
                    }
                    else
                    {
                        <span>&#x26A1;</span>
                    }
                </button>
            }
            else
            {
                <select class="form-select form-select-sm bg-dark text-light border-secondary" style="width:80px"
                        @bind="CurrentScheme">
                    <option value="https">https</option>
                    <option value="http">http</option>
                </select>
                <input class="form-control form-control-sm bg-dark text-light border-secondary" style="width:160px"
                       placeholder="Host" @bind="CurrentHost" @bind:event="oninput" />
                <input type="number" class="form-control form-control-sm bg-dark text-light border-secondary" style="width:70px"
                       placeholder="Port" @bind="CurrentPort" />
            }
            @if (TickMonitor.IsConnected)
            {
                <button class="btn btn-sm btn-outline-danger" @onclick="Disconnect">Disconnect</button>
                <span class="badge bg-success mono">Epoch @TickMonitor.Epoch | Tick @TickMonitor.Tick</span>
            }
            else
            {
                <button class="btn btn-sm btn-outline-info" @onclick="Reconnect" disabled="@_reconnecting">
                    @(_reconnecting ? "..." : "Connect")
                </button>
                @if (TickMonitor.Error != null)
                {
                    <span class="badge bg-danger" title="@TickMonitor.Error">Offline</span>
                }
                else
                {
                    <span class="badge bg-secondary">Not connected</span>
                }
            }
        </div>
    </nav>
    @if (_discoveryMessage != null)
    {
        <div class="@(_discoveryIsSwitch ? "bg-info" : "bg-success") text-dark text-center small py-1 d-flex justify-content-center align-items-center gap-2">
            <span>@_discoveryMessage</span>
            <button class="btn btn-sm btn-close" @onclick="DismissDiscovery"></button>
        </div>
    }
    @if (Seed.HasSeed)
    {
        <div class="bg-warning text-dark text-center small py-1">
            Your seed is held in memory for this session. Clear it when done.
        </div>
    }
    <div class="d-flex flex-grow-1 overflow-hidden">
        <NavMenu />
        <main class="flex-grow-1 overflow-auto p-4">
            @Body
        </main>
    </div>
</div>

@if (Settings.ExtendedServicesConfigured == null)
{
    <div class="modal d-block" tabindex="-1" style="background-color:rgba(0,0,0,0.6)">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header py-2">
                    <h6 class="modal-title">
                        <i class="bi bi-gear me-2"></i>Welcome to Qubic.Net Toolkit
                    </h6>
                </div>
                <div class="modal-body">
                    <p>Would you like to enable <strong>extended services</strong>?</p>
                    <p class="text-muted small mb-2">
                        Extended services fetch additional data from external servers to enhance the app experience.
                        This currently includes:
                    </p>
                    <ul class="small text-muted">
                        <li><strong>Address labels</strong> — display known names for exchanges, contracts, and tokens
                            (loaded from <code>static.qubic.org</code>)</li>
                    </ul>
                    <p class="text-muted small mb-0">
                        You can change this at any time in <strong>Settings</strong>.
                    </p>
                </div>
                <div class="modal-footer py-2">
                    <button class="btn btn-outline-secondary btn-sm" @onclick="() => ConfigureExtendedServices(false)">
                        No thanks
                    </button>
                    <button class="btn btn-primary btn-sm" @onclick="() => ConfigureExtendedServices(true)">
                        Enable extended services
                    </button>
                </div>
            </div>
        </div>
    </div>
}

@code {
    private string? _seedInput;
    private bool _reconnecting;
    private bool _discovering;
    private string? _discoveryMessage;
    private bool _discoveryIsSwitch;

    private string CurrentScheme
    {
        get => Backend.ActiveBackend == QueryBackend.Rpc ? Backend.RpcScheme : Backend.BobScheme;
        set { if (Backend.ActiveBackend == QueryBackend.Rpc) Backend.RpcScheme = value; else Backend.BobScheme = value; }
    }

    private string CurrentHost
    {
        get => Backend.ActiveBackend == QueryBackend.Rpc ? Backend.RpcHost : Backend.BobHost;
        set { if (Backend.ActiveBackend == QueryBackend.Rpc) Backend.RpcHost = value; else Backend.BobHost = value; }
    }

    private int CurrentPort
    {
        get => Backend.ActiveBackend == QueryBackend.Rpc ? Backend.RpcPort : Backend.BobPort;
        set { if (Backend.ActiveBackend == QueryBackend.Rpc) Backend.RpcPort = value; else Backend.BobPort = value; }
    }

    protected override async Task OnInitializedAsync()
    {
        TickMonitor.OnTickChanged += OnTickChanged;
        PeerAutoDiscover.OnDiscoveryCompleted += OnBackgroundDiscovery;
        PeerAutoDiscover.OnDiscoveryError += OnBackgroundDiscoveryError;
        await TickMonitor.StartAsync();

        if (Settings.ExtendedServicesConfigured == true && Settings.RemoteLabelsEnabled)
            _ = StaticData.LoadAsync();
    }

    private void ConfigureExtendedServices(bool enable)
    {
        Settings.RemoteLabelsEnabled = enable;
        Settings.ExtendedServicesConfigured = enable;

        if (enable)
            _ = StaticData.LoadAsync();
    }

    private bool _disposed;

    private void OnTickChanged()
    {
        if (_disposed) return;
        InvokeAsync(() => { if (!_disposed) StateHasChanged(); });
    }

    private void SetSeed()
    {
        if (_seedInput?.Length == 55)
        {
            try
            {
                Seed.SetSeed(_seedInput);
                WalletStorage.SetSeed(_seedInput, Seed.Identity!.Value.ToString());
                TxTracker.SetEncryptionKey(_seedInput);
                _seedInput = null;
            }
            catch { }
        }
    }

    private void ClearSeed()
    {
        Seed.ClearSeed();
        WalletStorage.ClearSeed();
        TxTracker.ClearEncryptionKey();
        _seedInput = null;
    }

    private async Task OnBackendChanged()
    {
        _discoveryMessage = null;
        Backend.ResetClients();
        PeerAutoDiscover.Restart();
        await TickMonitor.StartAsync();
    }

    private async Task Reconnect()
    {
        _reconnecting = true;
        StateHasChanged();
        Backend.ResetClients();
        await TickMonitor.StartAsync();
        _reconnecting = false;
    }

    private async Task Disconnect()
    {
        await TickMonitor.StopAsync();
        Backend.ResetClients();
    }

    private async Task AutoDiscover()
    {
        _discovering = true;
        _discoveryMessage = null;
        StateHasChanged();

        try
        {
            var threshold = Settings.GetCustom<int>("PeerTickThreshold") is > 0 and var t ? t : 10;
            var result = await Backend.AutoDiscoverRecentPeerAsync(threshold);

            if (result.Switched)
            {
                _discoveryIsSwitch = true;
                _discoveryMessage = $"Switched from {result.OriginalHost} (tick {result.OriginalTick:N0}) to {result.NewHost} (tick {result.BestTick:N0}) — scanned {result.PeersReachable}/{result.PeersScanned} peers";
                Backend.ResetClients();
                await TickMonitor.StartAsync();
            }
            else
            {
                _discoveryIsSwitch = false;
                _discoveryMessage = $"Current peer is up to date (tick {result.OriginalTick:N0}, best found: {result.BestTick:N0}) — scanned {result.PeersReachable}/{result.PeersScanned} peers";
            }
        }
        catch (Exception ex)
        {
            _discoveryIsSwitch = false;
            _discoveryMessage = $"Auto-discover failed: {ex.Message}";
        }
        finally
        {
            _discovering = false;
        }
    }

    private void OnBackgroundDiscovery(QubicBackendService.PeerDiscoveryResult result)
    {
        if (_disposed) return;
        InvokeAsync(() =>
        {
            if (_disposed) return;
            if (result.Switched)
            {
                _discoveryIsSwitch = true;
                _discoveryMessage = $"[Auto] Switched from {result.OriginalHost} (tick {result.OriginalTick:N0}) to {result.NewHost} (tick {result.BestTick:N0}) — scanned {result.PeersReachable}/{result.PeersScanned} peers";
            }
            else
            {
                _discoveryIsSwitch = false;
                _discoveryMessage = $"[Auto] Peer up to date (tick {result.OriginalTick:N0}, best: {result.BestTick:N0}) — {result.PeersReachable}/{result.PeersScanned} peers";
            }
            StateHasChanged();
        });
    }

    private void OnBackgroundDiscoveryError(string error)
    {
        if (_disposed) return;
        InvokeAsync(() =>
        {
            if (_disposed) return;
            _discoveryIsSwitch = false;
            _discoveryMessage = $"[Auto] Discovery failed: {error}";
            StateHasChanged();
        });
    }

    private void DismissDiscovery() => _discoveryMessage = null;

    public void Dispose()
    {
        _disposed = true;
        TickMonitor.OnTickChanged -= OnTickChanged;
        PeerAutoDiscover.OnDiscoveryCompleted -= OnBackgroundDiscovery;
        PeerAutoDiscover.OnDiscoveryError -= OnBackgroundDiscoveryError;
    }
}
