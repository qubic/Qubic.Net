@page "/node/peers"
@inject QubicBackendService Backend
@using Qubic.Network

<h4>Node Peers</h4>
<p class="text-muted">Discover peer IP addresses via ExchangePublicPeers. (DirectNetwork only)</p>

@if (Backend.ActiveBackend != QueryBackend.DirectNetwork)
{
    <div class="alert alert-warning">
        This feature requires the <strong>DirectNetwork</strong> backend. Switch to DirectNetwork in <a href="/settings">Settings</a>.
    </div>
}
else
{
    <div class="row g-2 align-items-end mb-3">
        <div class="col-auto">
            <label class="form-label mb-0">Depth</label>
            <select class="form-select form-select-sm" style="width:auto" @bind="_depth" disabled="@_loading">
                <option value="1">1 — Direct peers only</option>
                <option value="2">2 — Peers of peers</option>
                <option value="3">3 — Three levels deep</option>
            </select>
        </div>
        <div class="col-auto">
            <button class="btn btn-sm btn-primary" @onclick="FetchPeers" disabled="@_loading">
                @(_loading ? "Discovering..." : "Discover Peers")
            </button>
        </div>
    </div>

    @if (_status != null)
    {
        <div class="text-muted small mb-2">@_status</div>
    }

    @if (_error != null)
    {
        <div class="alert alert-danger">@_error</div>
    }

    @if (_results != null)
    {
        <div class="card">
            <div class="card-header">
                Discovered Peers (@_results.Count)
                @if (_depth > 1)
                {
                    <span class="text-muted ms-2">from @_nodesQueried nodes across @_depth levels</span>
                }
            </div>
            <div class="card-body">
                @if (_results.Count == 0)
                {
                    <span class="text-muted">No peers discovered.</span>
                }
                else
                {
                    <DataTable Items="_results" ShowRowNumbers="true">
                        <DataColumn TItem="PeerEntry" Title="IP Address" Field="@(p => p.Ip)" Filterable="true" Class="mono" DefaultSort="true" />
                        @if (_depth > 1)
                        {
                            <DataColumn TItem="PeerEntry" Title="Depth" Field="@(p => p.Depth)" />
                            <DataColumn TItem="PeerEntry" Title="Reported By" Field="@(p => p.Source)" Filterable="true" Class="mono text-muted small" />
                        }
                    </DataTable>
                }
            </div>
        </div>
    }
}

@code {
    private int _depth = 1;
    private bool _loading;
    private string? _error;
    private string? _status;
    private List<PeerEntry>? _results;
    private int _nodesQueried;

    private record PeerEntry(string Ip, int Depth, string Source);

    private async Task FetchPeers()
    {
        _loading = true;
        _error = null;
        _results = null;
        _status = null;
        _nodesQueried = 0;
        StateHasChanged();

        try
        {
            var allPeers = new Dictionary<string, PeerEntry>();
            var queried = new HashSet<string>();
            var queue = new Queue<(string Host, int Depth)>();

            // Seed with the configured node
            queue.Enqueue((Backend.NodeHost, 0));

            while (queue.Count > 0)
            {
                var (host, currentDepth) = queue.Dequeue();
                if (currentDepth >= _depth) continue;
                if (!queried.Add(host)) continue;

                _status = $"Querying {host} (depth {currentDepth + 1}/{_depth})...";
                _nodesQueried = queried.Count;
                StateHasChanged();
                await Task.Delay(1); // allow UI to update

                string[] peers;
                try
                {
                    using var node = new QubicNodeClient(host, Backend.NodePort);
                    await node.ConnectAsync();
                    peers = await node.GetPeerListAsync();
                }
                catch
                {
                    continue; // skip unreachable nodes
                }

                foreach (var ip in peers)
                {
                    if (!allPeers.ContainsKey(ip))
                    {
                        allPeers[ip] = new PeerEntry(ip, currentDepth + 1, host);
                        queue.Enqueue((ip, currentDepth + 1));
                    }
                }
            }

            _nodesQueried = queried.Count;
            _results = allPeers.Values.ToList();
            _status = null;
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
        finally
        {
            _loading = false;
        }
    }
}
