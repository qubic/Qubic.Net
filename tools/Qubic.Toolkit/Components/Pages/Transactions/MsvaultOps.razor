@page "/tx/msvault"
@inject QubicBackendService Backend
@inject SeedSessionService Seed
@inject TickMonitorService TickMonitor
@inject TransactionTrackerService TxTracker
@inject QubicSettingsService Settings

<h4>MSVault (Multisig)</h4>
<p class="text-muted">Manage multisig vaults: register, deposit, release, and vote on fee changes.</p>

@if (_fees != null)
{
    <div class="small text-muted mb-2">
        Fees &mdash; Register: <strong>@_fees.Value.register.ToString("N0")</strong> |
        Release: <strong>@_fees.Value.release.ToString("N0")</strong> |
        Reset: <strong>@_fees.Value.reset.ToString("N0")</strong> |
        Holding: <strong>@_fees.Value.holding.ToString("N0")</strong> |
        Deposit: <strong>@_fees.Value.deposit.ToString("N0")</strong> |
        Burn: <strong>@_fees.Value.burn.ToString("N0")</strong>
    </div>
}

@if (!Seed.HasSeed)
{
    <div class="seed-warning">Enter your seed in the top bar to enable signing.</div>
}
else
{
    <ul class="nav nav-tabs mb-3">
        @foreach (var tab in _tabs)
        {
            <li class="nav-item">
                <a class="nav-link @(tab == _activeTab ? "active" : "")" href="" @onclick="() => _activeTab = tab" @onclick:preventDefault>@tab</a>
            </li>
        }
    </ul>

    <div class="row"><div class="col-md-8">
        @switch (_activeTab)
        {
            case "Register":
                <div class="card"><div class="card-header">Register Vault</div><div class="card-body">
                    <p class="small text-muted">Create a new multisig vault. Note: owner identities are not included in the generated payload due to a known limitation.</p>
                    <div class="mb-2"><label class="form-label-sm">Vault Name (32 bytes, identity format)</label>
                        <input class="form-control form-control-sm mono @IdentityValidation.CssClass(_regVaultName)"
                               @bind="_regVaultName" placeholder="IDENTITY..." /></div>
                    <div class="mb-2"><label class="form-label-sm">Required Approvals</label>
                        <input type="number" class="form-control form-control-sm" min="1" @bind="_regApprovals" /></div>
                    <div class="mb-2"><label class="form-label-sm">Registration Fee (QU)</label>
                        <input type="number" class="form-control form-control-sm" min="0" @bind="_regFee" /></div>
                    <button class="btn btn-primary" @onclick="RegisterVault" disabled="@_sending">@(_sending ? "Registering..." : "Register Vault")</button>
                </div></div>
                break;

            case "Deposit":
                <div class="card"><div class="card-header">Deposit to Vault</div><div class="card-body">
                    <div class="mb-2"><label class="form-label-sm">Vault ID</label>
                        <input type="number" class="form-control form-control-sm" min="0" @bind="_depVaultId" /></div>
                    <div class="mb-2"><label class="form-label-sm">Amount (QU)</label>
                        <input type="number" class="form-control form-control-sm" min="1" @bind="_depAmount" /></div>
                    <button class="btn btn-primary" @onclick="Deposit" disabled="@_sending">@(_sending ? "Depositing..." : "Deposit")</button>
                </div></div>
                break;

            case "Release":
                <div class="card"><div class="card-header">Release / Reset</div><div class="card-body">
                    <div class="mb-2">
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="relMode" checked="@(!_resetMode)" @onchange="() => _resetMode = false" />
                            <label class="form-check-label">Release To</label>
                        </div>
                        <div class="form-check form-check-inline">
                            <input class="form-check-input" type="radio" name="relMode" checked="@_resetMode" @onchange="() => _resetMode = true" />
                            <label class="form-check-label">Reset Release</label>
                        </div>
                    </div>
                    <div class="mb-2"><label class="form-label-sm">Vault ID</label>
                        <input type="number" class="form-control form-control-sm" min="0" @bind="_relVaultId" /></div>
                    @if (!_resetMode)
                    {
                        <div class="mb-2"><label class="form-label-sm">Destination Identity</label>
                            <input class="form-control form-control-sm mono @IdentityValidation.CssClass(_relDest)"
                                   @bind="_relDest" placeholder="IDENTITY..." /></div>
                        <div class="mb-2"><label class="form-label-sm">Amount (QU)</label>
                            <input type="number" class="form-control form-control-sm" min="0" @bind="_relAmount" /></div>
                        <div class="mb-2"><label class="form-label-sm">Release Fee (QU)</label>
                            <input type="number" class="form-control form-control-sm" min="0" @bind="_relFee" /></div>
                    }
                    <button class="btn btn-primary" @onclick="ReleaseOrReset" disabled="@_sending">
                        @(_sending ? "Sending..." : (_resetMode ? "Reset Release" : "Release To"))
                    </button>
                </div></div>
                break;

            case "Vote Fee":
                <div class="card"><div class="card-header">Vote Fee Change</div><div class="card-body">
                    <p class="small text-muted">Propose new fee values for vault operations.</p>
                    <div class="row g-2 mb-2">
                        <div class="col-md-4"><label class="form-label-sm">New Registering Fee</label>
                            <input type="number" class="form-control form-control-sm" min="0" @bind="_vfRegFee" /></div>
                        <div class="col-md-4"><label class="form-label-sm">New Release Fee</label>
                            <input type="number" class="form-control form-control-sm" min="0" @bind="_vfRelFee" /></div>
                        <div class="col-md-4"><label class="form-label-sm">New Reset Fee</label>
                            <input type="number" class="form-control form-control-sm" min="0" @bind="_vfResetFee" /></div>
                    </div>
                    <div class="row g-2 mb-2">
                        <div class="col-md-4"><label class="form-label-sm">New Holding Fee</label>
                            <input type="number" class="form-control form-control-sm" min="0" @bind="_vfHoldFee" /></div>
                        <div class="col-md-4"><label class="form-label-sm">New Deposit Fee</label>
                            <input type="number" class="form-control form-control-sm" min="0" @bind="_vfDepFee" /></div>
                        <div class="col-md-4"><label class="form-label-sm">Burn Fee</label>
                            <input type="number" class="form-control form-control-sm" min="0" @bind="_vfBurnFee" /></div>
                    </div>
                    <button class="btn btn-primary" @onclick="VoteFeeChange" disabled="@_sending">@(_sending ? "Voting..." : "Vote Fee Change")</button>
                </div></div>
                break;

            case "Assets":
                <div class="card"><div class="card-header">Asset Operations</div><div class="card-body">
                    <div class="mb-2">
                        <select class="form-select form-select-sm" @bind="_assetOp">
                            <option value="deposit">Deposit Asset</option>
                            <option value="release">Release Asset To</option>
                            <option value="reset">Reset Asset Release</option>
                            <option value="revoke">Revoke Asset Management Rights</option>
                        </select>
                    </div>
                    @if (_assetOp != "revoke")
                    {
                        <div class="mb-2"><label class="form-label-sm">Vault ID</label>
                            <input type="number" class="form-control form-control-sm" min="0" @bind="_aVaultId" /></div>
                    }
                    <AssetSelector @bind-IssuerValue="_aIssuer" @bind-NameValue="_aName" />
                    @if (_assetOp is "deposit" or "release" or "revoke")
                    {
                        <div class="mb-2"><label class="form-label-sm">@(_assetOp == "revoke" ? "Number of Shares" : "Amount")</label>
                            <input type="number" class="form-control form-control-sm" min="0" @bind="_aAmount" /></div>
                    }
                    @if (_assetOp == "release")
                    {
                        <div class="mb-2"><label class="form-label-sm">Destination Identity</label>
                            <input class="form-control form-control-sm mono @IdentityValidation.CssClass(_aDest)"
                                   @bind="_aDest" placeholder="IDENTITY..." /></div>
                    }
                    <button class="btn btn-primary" @onclick="AssetOp" disabled="@_sending">@(_sending ? "Sending..." : "Submit")</button>
                </div></div>
                break;

            case "Query":
                <div class="card"><div class="card-header">Query MSVault</div><div class="card-body">
                    <div class="mb-3">
                        <label class="form-label-sm">Query Function</label>
                        <select class="form-select form-select-sm" @bind="_queryFunc">
                            <option value="5">Get Vaults (by owner)</option>
                            <option value="7">Get Balance</option>
                            <option value="8">Get Vault Name</option>
                            <option value="11">Get Vault Owners</option>
                            <option value="6">Get Release Status</option>
                            <option value="12">Is Shareholder</option>
                            <option value="10">Get Fees</option>
                        </select>
                    </div>

                    @if (_queryFunc is 5 or 12)
                    {
                        <div class="mb-2"><label class="form-label-sm">Identity</label>
                            <input class="form-control form-control-sm mono @IdentityValidation.CssClass(_qIdentity)"
                                   @bind="_qIdentity" @bind:event="oninput" placeholder="IDENTITY..." /></div>
                    }
                    @if (_queryFunc is 6 or 7 or 8 or 11)
                    {
                        <div class="mb-2"><label class="form-label-sm">Vault ID</label>
                            <input type="number" class="form-control form-control-sm" min="0" @bind="_qVaultId" /></div>
                    }

                    <button class="btn btn-primary" @onclick="RunQuery" disabled="@_querying">
                        @(_querying ? "Querying..." : "Query")
                    </button>

                    @if (_queryResult != null)
                    {
                        <div class="mt-3">
                            <table class="table table-sm table-bordered">
                                <tbody>
                                    @foreach (var kv in _queryResult)
                                    {
                                        <tr><th class="text-muted" style="width:40%">@kv.Key</th><td class="mono">@kv.Value</td></tr>
                                    }
                                </tbody>
                            </table>
                        </div>
                    }
                </div></div>
                break;
        }

        @if (_result != null)
        {
            <div class="alert alert-success mt-3">
                Transaction broadcast! Tx ID: <span class="mono">@_result</span>
                <div class="mt-1">
                    <a href="https://explorer.qubic.org/network/tx/@_result" target="_blank" rel="noopener" class="me-3">View on Explorer</a>
                    <a href="/tx/history">Transaction History</a>
                </div>
            </div>
        }
        @if (_error != null) { <div class="alert alert-danger mt-2">@_error</div> }
    </div></div>
}

@code {
    private static readonly string[] _tabs = ["Register", "Deposit", "Release", "Vote Fee", "Assets", "Query"];
    private string _activeTab = "Deposit";
    private bool _sending;
    private string? _result;
    private string? _error;
    private const int ContractIndex = 11;
    private (ulong register, ulong release, ulong reset, ulong holding, ulong deposit, ulong burn)? _fees;

    // Register
    private string _regVaultName = ""; private ulong _regApprovals = 1; private long _regFee;
    // Deposit
    private ulong _depVaultId; private long _depAmount;
    // Release
    private bool _resetMode; private ulong _relVaultId; private string _relDest = ""; private ulong _relAmount; private long _relFee;
    // Vote Fee
    private ulong _vfRegFee; private ulong _vfRelFee; private ulong _vfResetFee;
    private ulong _vfHoldFee; private ulong _vfDepFee; private ulong _vfBurnFee;
    // Assets
    private string _assetOp = "deposit"; private ulong _aVaultId;
    private string _aIssuer = ""; private string _aName = ""; private long _aAmount; private string _aDest = "";
    // Query
    private int _queryFunc = 5;
    private string? _qIdentity;
    private ulong _qVaultId;
    private bool _querying;
    private List<KeyValuePair<string, string>>? _queryResult;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            var result = await Backend.QuerySmartContractAsync(ContractIndex, 10, []);
            if (result.Length >= 48)
                _fees = (BitConverter.ToUInt64(result, 0), BitConverter.ToUInt64(result, 8),
                         BitConverter.ToUInt64(result, 16), BitConverter.ToUInt64(result, 24),
                         BitConverter.ToUInt64(result, 32), BitConverter.ToUInt64(result, 40));
        }
        catch { }
    }

    private async Task<uint> GetTick() => TickMonitor.IsConnected
        ? TickMonitor.Tick + (uint)Settings.TickOffset
        : (await Backend.GetTickInfoAsync()).Tick + (uint)Settings.TickOffset;

    private async Task Broadcast(long amount, uint tick, Qubic.Core.Payloads.ITransactionPayload payload, string desc)
    {
        var dest = Qubic.Core.Entities.QubicIdentity.FromPublicKey(Qubic.Core.QubicContracts.GetContractPublicKey(ContractIndex));
        var tx = Seed.CreateAndSignTransaction(dest, amount, tick, payload);
        var result = await Backend.BroadcastTransactionAsync(tx);
        _result = result.TransactionId;
        TxTracker.Track(new TrackedTransaction { Hash = result.TransactionId, Source = Seed.Identity?.ToString() ?? "",
            Destination = dest.ToString(), Amount = amount, TargetTick = tick,
            InputType = payload.InputType, PayloadHex = Convert.ToHexString(payload.GetPayloadBytes()), Description = desc });
    }

    private async Task RegisterVault()
    {
        _sending = true; _error = null; _result = null;
        try
        {
            var err = IdentityValidation.Validate(_regVaultName);
            if (err != null) { _error = $"Vault Name: {err}"; return; }
            var tick = await GetTick();
            var payload = new Qubic.Core.Contracts.Msvault.RegisterVaultPayload
            {
                VaultName = Qubic.Core.Entities.QubicIdentity.FromIdentity(_regVaultName.Trim()).PublicKey,
                Owners = [], RequiredApprovals = _regApprovals
            };
            await Broadcast(_regFee, tick, payload, $"MSVault Register: approvals={_regApprovals}");
        }
        catch (Exception ex) { _error = ex.Message; }
        finally { _sending = false; }
    }

    private async Task Deposit()
    {
        _sending = true; _error = null; _result = null;
        try
        {
            if (_depAmount <= 0) { _error = "Amount must be positive."; return; }
            var tick = await GetTick();
            var payload = new Qubic.Core.Contracts.Msvault.DepositPayload { VaultId = _depVaultId };
            await Broadcast(_depAmount, tick, payload, $"MSVault Deposit: vault {_depVaultId}, {_depAmount:N0} QU");
        }
        catch (Exception ex) { _error = ex.Message; }
        finally { _sending = false; }
    }

    private async Task ReleaseOrReset()
    {
        _sending = true; _error = null; _result = null;
        try
        {
            var tick = await GetTick();
            if (_resetMode)
            {
                var payload = new Qubic.Core.Contracts.Msvault.ResetReleasePayload { VaultId = _relVaultId };
                await Broadcast(0, tick, payload, $"MSVault Reset Release: vault {_relVaultId}");
            }
            else
            {
                var err = IdentityValidation.Validate(_relDest);
                if (err != null) { _error = $"Destination: {err}"; return; }
                var payload = new Qubic.Core.Contracts.Msvault.ReleaseToPayload
                {
                    VaultId = _relVaultId, Amount = _relAmount,
                    Destination = Qubic.Core.Entities.QubicIdentity.FromIdentity(_relDest.Trim()).PublicKey
                };
                await Broadcast(_relFee, tick, payload, $"MSVault Release: vault {_relVaultId}, {_relAmount:N0} QU");
            }
        }
        catch (Exception ex) { _error = ex.Message; }
        finally { _sending = false; }
    }

    private async Task VoteFeeChange()
    {
        _sending = true; _error = null; _result = null;
        try
        {
            var tick = await GetTick();
            var payload = new Qubic.Core.Contracts.Msvault.VoteFeeChangePayload
            {
                NewRegisteringFee = _vfRegFee, NewReleaseFee = _vfRelFee,
                NewReleaseResetFee = _vfResetFee, NewHoldingFee = _vfHoldFee,
                NewDepositFee = _vfDepFee, BurnFee = _vfBurnFee
            };
            await Broadcast(0, tick, payload, "MSVault Vote Fee Change");
        }
        catch (Exception ex) { _error = ex.Message; }
        finally { _sending = false; }
    }

    private Qubic.Core.Contracts.QubicAsset ParseAsset()
    {
        var issuerPk = Qubic.Core.Entities.QubicIdentity.FromIdentity(_aIssuer.Trim()).PublicKey;
        var assetName = AssetNameHelper.ToUlong(_aName.Trim());
        return new Qubic.Core.Contracts.QubicAsset { Issuer = issuerPk, AssetName = assetName };
    }

    private async Task AssetOp()
    {
        _sending = true; _error = null; _result = null;
        try
        {
            var err = IdentityValidation.Validate(_aIssuer);
            if (err != null) { _error = $"Asset Issuer: {err}"; return; }
            if (string.IsNullOrWhiteSpace(_aName)) { _error = "Asset name required."; return; }

            var tick = await GetTick();
            var asset = ParseAsset();

            switch (_assetOp)
            {
                case "deposit":
                    var dp = new Qubic.Core.Contracts.Msvault.DepositAssetPayload { VaultId = _aVaultId, Asset = asset, Amount = (ulong)_aAmount };
                    await Broadcast(0, tick, dp, $"MSVault Deposit Asset: vault {_aVaultId}, {_aName} x{_aAmount}");
                    break;
                case "release":
                    var re = IdentityValidation.Validate(_aDest);
                    if (re != null) { _error = $"Destination: {re}"; return; }
                    var rp = new Qubic.Core.Contracts.Msvault.ReleaseAssetToPayload
                    {
                        VaultId = _aVaultId, Asset = asset, Amount = (ulong)_aAmount,
                        Destination = Qubic.Core.Entities.QubicIdentity.FromIdentity(_aDest.Trim()).PublicKey
                    };
                    await Broadcast(0, tick, rp, $"MSVault Release Asset: vault {_aVaultId}, {_aName} x{_aAmount}");
                    break;
                case "reset":
                    var rap = new Qubic.Core.Contracts.Msvault.ResetAssetReleasePayload { VaultId = _aVaultId };
                    await Broadcast(0, tick, rap, $"MSVault Reset Asset Release: vault {_aVaultId}");
                    break;
                case "revoke":
                    var rvp = new Qubic.Core.Contracts.Msvault.RevokeAssetManagementRightsPayload { Asset = asset, NumberOfShares = _aAmount };
                    await Broadcast(0, tick, rvp, $"MSVault Revoke Mgmt Rights: {_aName} x{_aAmount}");
                    break;
            }
        }
        catch (Exception ex) { _error = ex.Message; }
        finally { _sending = false; }
    }

    private byte[] GetQueryPk()
    {
        var err = IdentityValidation.Validate(_qIdentity);
        if (err != null) throw new Exception("Identity: " + err);
        return Qubic.Core.Entities.QubicIdentity.FromIdentity(_qIdentity!.Trim()).PublicKey;
    }

    private string PkToIdentity(byte[] pk)
    {
        try { return Qubic.Core.Entities.QubicIdentity.FromPublicKey(pk).ToString(); }
        catch { return Convert.ToHexString(pk); }
    }

    private async Task RunQuery()
    {
        _querying = true; _error = null; _queryResult = null;
        try
        {
            byte[] input;
            switch (_queryFunc)
            {
                case 5: input = new Qubic.Core.Contracts.Msvault.GetVaultsInput { PublicKey = GetQueryPk() }.ToBytes(); break;
                case 6: input = new Qubic.Core.Contracts.Msvault.GetReleaseStatusInput { VaultId = _qVaultId }.ToBytes(); break;
                case 7: input = new Qubic.Core.Contracts.Msvault.GetBalanceOfInput { VaultId = _qVaultId }.ToBytes(); break;
                case 8: input = new Qubic.Core.Contracts.Msvault.GetVaultNameInput { VaultId = _qVaultId }.ToBytes(); break;
                case 10: input = []; break;
                case 11: input = new Qubic.Core.Contracts.Msvault.GetVaultOwnersInput { VaultId = _qVaultId }.ToBytes(); break;
                case 12: input = new Qubic.Core.Contracts.Msvault.IsShareHolderInput { Candidate = GetQueryPk() }.ToBytes(); break;
                default: return;
            }

            var result = await Backend.QuerySmartContractAsync(ContractIndex, (uint)_queryFunc, input);
            _queryResult = ParseMsvaultResult(_queryFunc, result);
        }
        catch (Exception ex) { _error = ex.Message; }
        finally { _querying = false; }
    }

    private List<KeyValuePair<string, string>> ParseMsvaultResult(int func, byte[] data)
    {
        var list = new List<KeyValuePair<string, string>>();
        switch (func)
        {
            case 5 when data.Length >= 8: // GetVaults
                var numVaults = BitConverter.ToUInt64(data, 0);
                list.Add(new("Number of Vaults", numVaults.ToString()));
                var maxVaults = Math.Min((int)numVaults, 64);
                for (int i = 0; i < maxVaults && 8 + i * 8 + 8 <= data.Length; i++)
                    list.Add(new($"Vault ID #{i + 1}", BitConverter.ToUInt64(data, 8 + i * 8).ToString()));
                var namesOffset = 8 + maxVaults * 8;
                for (int i = 0; i < maxVaults && namesOffset + i * 32 + 32 <= data.Length; i++)
                {
                    var namePk = data.AsSpan(namesOffset + i * 32, 32).ToArray();
                    list.Add(new($"Vault Name #{i + 1}", PkToIdentity(namePk)));
                }
                break;

            case 6 when data.Length >= 8: // GetReleaseStatus
                list.Add(new("Status", BitConverter.ToUInt64(data, 0).ToString()));
                if (data.Length > 8)
                    list.Add(new("Raw Data", Convert.ToHexString(data.AsSpan(8))));
                break;

            case 7 when data.Length >= 16: // GetBalanceOf
                var bo = Qubic.Core.Contracts.Msvault.GetBalanceOfOutput.FromBytes(data);
                list.Add(new("Status", bo.Status.ToString()));
                list.Add(new("Balance", bo.Balance.ToString("N0")));
                break;

            case 8 when data.Length >= 40: // GetVaultName
                var vn = Qubic.Core.Contracts.Msvault.GetVaultNameOutput.FromBytes(data);
                list.Add(new("Status", vn.Status.ToString()));
                list.Add(new("Vault Name", PkToIdentity(vn.VaultName)));
                break;

            case 10 when data.Length >= 48: // GetFees
                var fees = Qubic.Core.Contracts.Msvault.GetFeesOutput.FromBytes(data);
                list.Add(new("Registering Fee", fees.RegisteringFee.ToString("N0")));
                list.Add(new("Release Fee", fees.ReleaseFee.ToString("N0")));
                list.Add(new("Release Reset Fee", fees.ReleaseResetFee.ToString("N0")));
                list.Add(new("Holding Fee", fees.HoldingFee.ToString("N0")));
                list.Add(new("Deposit Fee", fees.DepositFee.ToString("N0")));
                list.Add(new("Burn Fee", fees.BurnFee.ToString("N0")));
                break;

            case 11 when data.Length >= 16: // GetVaultOwners
                var ownerStatus = BitConverter.ToUInt64(data, 0);
                var numOwners = BitConverter.ToUInt64(data, 8);
                list.Add(new("Status", ownerStatus.ToString()));
                list.Add(new("Number of Owners", numOwners.ToString()));
                var maxOwners = Math.Min((int)numOwners, 64);
                for (int i = 0; i < maxOwners && 16 + i * 32 + 32 <= data.Length; i++)
                {
                    var ownerPk = data.AsSpan(16 + i * 32, 32).ToArray();
                    list.Add(new($"Owner #{i + 1}", PkToIdentity(ownerPk)));
                }
                var reqOffset = 16 + maxOwners * 32;
                if (reqOffset + 8 <= data.Length)
                    list.Add(new("Required Approvals", BitConverter.ToUInt64(data, reqOffset).ToString()));
                break;

            case 12 when data.Length >= 8: // IsShareHolder
                var sh = Qubic.Core.Contracts.Msvault.IsShareHolderOutput.FromBytes(data);
                list.Add(new("Result", sh.Result != 0 ? "Yes (shareholder)" : "No"));
                list.Add(new("Raw Value", sh.Result.ToString()));
                break;

            default:
                list.Add(new("Result", data.Length > 0 ? Convert.ToHexString(data) : "(empty)"));
                break;
        }
        return list;
    }
}
