@page "/tx/offline"
@inject QubicBackendService Backend
@inject SeedSessionService Seed

<h4>Offline Transaction Builder</h4>
<p class="text-muted">Build and sign a transaction offline. Export as hex or base64 for later broadcast.</p>

@if (!Seed.HasSeed)
{
    <div class="seed-warning">Enter your seed in the top bar to enable signing.</div>
}
else
{
    <div class="row">
        <div class="col-md-8">
            <div class="card">
                <div class="card-header">Build Transaction</div>
                <div class="card-body">
                    <div class="mb-2">
                        <label class="form-label-sm">Destination (60-char identity or contract index 0-23)</label>
                        <input class="form-control form-control-sm @IdentityValidation.DestCssClass(_destination)"
                               placeholder="Identity or contract index" @bind="_destination" @bind:event="oninput" />
                        @{ var destErr = IdentityValidation.ValidateDestination(_destination); }
                        @if (destErr != null)
                        {
                            <div class="small text-danger mt-1">@destErr</div>
                        }
                    </div>
                    <div class="row g-2 mb-2">
                        <div class="col">
                            <label class="form-label-sm">Amount (QU)</label>
                            <input type="number" class="form-control form-control-sm" @bind="_amount" />
                        </div>
                        <div class="col">
                            <label class="form-label-sm">Input Type</label>
                            <input type="number" class="form-control form-control-sm" @bind="_inputType" />
                        </div>
                        <div class="col">
                            <label class="form-label-sm">Tick</label>
                            <input type="number" class="form-control form-control-sm" @bind="_tick" />
                        </div>
                    </div>
                    <div class="mb-3">
                        <label class="form-label-sm">Payload (hex, optional)</label>
                        <textarea class="form-control form-control-sm mono" rows="2" @bind="_payloadHex"></textarea>
                    </div>

                    <button class="btn btn-primary" @onclick="Build" disabled="@(_tick == 0)">
                        Sign & Export
                    </button>

                    @if (_error != null)
                    {
                        <div class="alert alert-danger mt-2">@_error</div>
                    }
                </div>
            </div>

            @if (_signedHex != null)
            {
                <div class="card mt-3">
                    <div class="card-header">Signed Transaction</div>
                    <div class="card-body">
                        <div class="mb-2">
                            <label class="form-label-sm">Tx ID</label>
                            <input class="form-control form-control-sm mono" value="@_txHash" readonly />
                        </div>
                        <div class="mb-2">
                            <label class="form-label-sm">Hex (@_signedHex.Length / 2 bytes)</label>
                            <textarea class="form-control form-control-sm mono" rows="4" readonly>@_signedHex</textarea>
                        </div>
                        <div class="mb-2">
                            <label class="form-label-sm">Base64</label>
                            <textarea class="form-control form-control-sm mono" rows="3" readonly>@_signedBase64</textarea>
                        </div>
                    </div>
                </div>
            }
        </div>
    </div>
}

@code {
    private string? _destination;
    private long _amount;
    private ushort _inputType;
    private uint _tick;
    private string? _payloadHex;
    private string? _signedHex;
    private string? _signedBase64;
    private string? _txHash;
    private string? _error;

    private void Build()
    {
        _error = null;
        _signedHex = null;
        _signedBase64 = null;
        _txHash = null;

        try
        {
            // Validate destination
            if (string.IsNullOrWhiteSpace(_destination))
            {
                _error = "Destination is required.";
                return;
            }
            var destErr = IdentityValidation.ValidateDestination(_destination);
            if (destErr != null)
            {
                _error = "Destination: " + destErr;
                return;
            }

            Qubic.Core.Entities.QubicIdentity dest;
            if (int.TryParse(_destination.Trim(), out var contractIdx) && contractIdx is >= 0 and <= 23)
                dest = Qubic.Core.Entities.QubicIdentity.FromPublicKey(Qubic.Core.QubicContracts.GetContractPublicKey(contractIdx));
            else
                dest = Qubic.Core.Entities.QubicIdentity.FromIdentity(_destination.Trim());

            var data = string.IsNullOrWhiteSpace(_payloadHex) ? [] : Convert.FromHexString(_payloadHex.Trim());
            var payload = new GenericContractPayload(_inputType, data);

            var tx = Seed.CreateAndSignTransaction(dest, _amount, _tick, payload);

            // Serialize signed tx: header (80) + payload + signature (64)
            var payloadSize = tx.Payload?.Length ?? 0;
            var totalSize = 32 + 32 + 8 + 4 + 2 + 2 + payloadSize + 64;
            var bytes = new byte[totalSize];
            var offset = 0;

            Array.Copy(tx.SourceIdentity.PublicKey, 0, bytes, offset, 32); offset += 32;
            Array.Copy(tx.DestinationIdentity.PublicKey, 0, bytes, offset, 32); offset += 32;
            BitConverter.TryWriteBytes(bytes.AsSpan(offset), tx.Amount); offset += 8;
            BitConverter.TryWriteBytes(bytes.AsSpan(offset), tx.Tick); offset += 4;
            BitConverter.TryWriteBytes(bytes.AsSpan(offset), tx.InputType); offset += 2;
            BitConverter.TryWriteBytes(bytes.AsSpan(offset), tx.InputSize); offset += 2;
            if (tx.Payload is { Length: > 0 })
            {
                Array.Copy(tx.Payload, 0, bytes, offset, tx.Payload.Length);
                offset += tx.Payload.Length;
            }
            Array.Copy(tx.Signature!, 0, bytes, offset, 64);

            _signedHex = Convert.ToHexString(bytes).ToLowerInvariant();
            _signedBase64 = Convert.ToBase64String(bytes);
            _txHash = tx.TransactionHash;
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
    }
}
