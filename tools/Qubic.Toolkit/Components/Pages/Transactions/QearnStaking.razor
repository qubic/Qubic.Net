@page "/tx/qearn"
@inject QubicBackendService Backend
@inject SeedSessionService Seed
@inject TickMonitorService TickMonitor
@inject TransactionTrackerService TxTracker
@inject QubicSettingsService Settings

<h4>QEarn Staking</h4>
<p class="text-muted">Lock QU to earn rewards, unlock, and query staking information.</p>

<ul class="nav nav-tabs mb-3">
    @foreach (var tab in _tabs)
    {
        <li class="nav-item">
            <a class="nav-link @(tab == _activeTab ? "active" : "")" href="" @onclick="() => _activeTab = tab" @onclick:preventDefault>@tab</a>
        </li>
    }
</ul>

<div class="row"><div class="col-md-8">
    @switch (_activeTab)
    {
        case "Lock":
            <div class="card"><div class="card-header">Lock QU</div><div class="card-body">
                <p class="small text-muted">Lock QU into QEarn smart contract to earn staking rewards.</p>
                <div class="mb-2">
                    <label class="form-label-sm">Amount to lock (QU)</label>
                    <input type="number" class="form-control form-control-sm" min="1" @bind="_lockAmount" />
                </div>
                <button class="btn btn-primary" @onclick="Lock" disabled="@(_sending || _lockAmount <= 0)">
                    @(_sending ? "Locking..." : "Lock")
                </button>
            </div></div>
            break;

        case "Unlock":
            <div class="card"><div class="card-header">Unlock QU</div><div class="card-body">
                <p class="small text-muted">Unlock previously locked QU. Early unlock may incur penalties.</p>
                <div class="mb-2">
                    <label class="form-label-sm">Amount to unlock (QU)</label>
                    <input type="number" class="form-control form-control-sm" min="1" @bind="_unlockAmount" />
                </div>
                <div class="mb-2">
                    <label class="form-label-sm">Locked Epoch</label>
                    <input type="number" class="form-control form-control-sm" min="0" @bind="_unlockEpoch" />
                </div>
                <button class="btn btn-warning" @onclick="Unlock" disabled="@(_sending || _unlockAmount <= 0)">
                    @(_sending ? "Unlocking..." : "Unlock")
                </button>
            </div></div>
            break;

        case "Query":
            <div class="card"><div class="card-header">Query QEarn</div><div class="card-body">
                <div class="mb-3">
                    <label class="form-label-sm">Query Function</label>
                    <select class="form-select form-select-sm" @bind="_queryFunc">
                        <option value="1">Lock Info Per Epoch</option>
                        <option value="2">User Locked Info</option>
                        <option value="3">State of Round</option>
                        <option value="4">User Lock Status (52-week bitmask)</option>
                        <option value="5">Ended Status</option>
                        <option value="6">Stats Per Epoch</option>
                        <option value="7">Burned &amp; Boosted Stats (global)</option>
                        <option value="8">Burned &amp; Boosted Stats Per Epoch</option>
                    </select>
                </div>

                @if (_queryFunc is 1 or 3 or 6 or 8)
                {
                    <div class="mb-2">
                        <label class="form-label-sm">Epoch</label>
                        <input type="number" class="form-control form-control-sm" min="0" @bind="_qEpoch" />
                    </div>
                }
                @if (_queryFunc is 2 or 4 or 5)
                {
                    <div class="mb-2">
                        <label class="form-label-sm">User Identity</label>
                        <input class="form-control form-control-sm mono @IdentityValidation.CssClass(_qIdentity)"
                               @bind="_qIdentity" @bind:event="oninput" placeholder="IDENTITY..." />
                    </div>
                }
                @if (_queryFunc == 2)
                {
                    <div class="mb-2">
                        <label class="form-label-sm">Epoch</label>
                        <input type="number" class="form-control form-control-sm" min="0" @bind="_qEpoch" />
                    </div>
                }

                <button class="btn btn-primary" @onclick="RunQuery" disabled="@_querying">
                    @(_querying ? "Querying..." : "Query")
                </button>

                @if (_queryResult != null)
                {
                    <div class="mt-3">
                        <table class="table table-sm table-bordered">
                            <tbody>
                                @foreach (var kv in _queryResult)
                                {
                                    <tr><th class="text-muted" style="width:40%">@kv.Key</th><td class="mono">@kv.Value</td></tr>
                                }
                            </tbody>
                        </table>
                    </div>
                }

                @if (_lockStatusBits != null)
                {
                    <div class="mt-3">
                        <label class="form-label-sm">Lock Status (52 weeks, bit 0 = earliest)</label>
                        <div class="d-flex flex-wrap gap-1 mt-1">
                            @for (int i = 0; i < 52; i++)
                            {
                                var bit = i;
                                var locked = (_lockStatusBits.Value >> bit & 1) == 1;
                                <span class="badge @(locked ? "bg-success" : "bg-secondary")" title="Week @(bit + 1)"
                                      style="width:24px; font-size:0.65rem">@(bit + 1)</span>
                            }
                        </div>
                        <div class="small text-muted mt-1">
                            <span class="badge bg-success">N</span> = locked &nbsp;
                            <span class="badge bg-secondary">N</span> = not locked
                        </div>
                    </div>
                }
            </div></div>
            break;
    }

    @if (_result != null)
    {
        <div class="alert alert-success mt-3">
            Transaction broadcast! Tx ID: <span class="mono">@_result</span>
            <div class="mt-1">
                <a href="https://explorer.qubic.org/network/tx/@_result" target="_blank" rel="noopener" class="me-3">View on Explorer</a>
                <a href="/tx/history">Transaction History</a>
            </div>
        </div>
    }
    @if (_error != null) { <div class="alert alert-danger mt-2">@_error</div> }
</div></div>

@code {
    private static readonly string[] _tabs = ["Lock", "Unlock", "Query"];
    private string _activeTab = "Lock";
    private bool _sending;
    private string? _result;
    private string? _error;
    private const int ContractIndex = 9;

    // Lock
    private long _lockAmount;
    // Unlock
    private long _unlockAmount;
    private uint _unlockEpoch;

    // Query
    private int _queryFunc = 1;
    private uint _qEpoch;
    private string? _qIdentity;
    private bool _querying;
    private List<KeyValuePair<string, string>>? _queryResult;
    private ulong? _lockStatusBits;

    private async Task<uint> GetTick() => TickMonitor.IsConnected
        ? TickMonitor.Tick + (uint)Settings.TickOffset
        : (await Backend.GetTickInfoAsync()).Tick + (uint)Settings.TickOffset;

    private async Task Broadcast(long amount, uint tick, Qubic.Core.Payloads.ITransactionPayload payload, string desc)
    {
        var dest = Qubic.Core.Entities.QubicIdentity.FromPublicKey(Qubic.Core.QubicContracts.GetContractPublicKey(ContractIndex));
        var tx = Seed.CreateAndSignTransaction(dest, amount, tick, payload);
        var result = await Backend.BroadcastTransactionAsync(tx);
        _result = result.TransactionId;
        TxTracker.Track(new TrackedTransaction { Hash = result.TransactionId, Source = Seed.Identity?.ToString() ?? "",
            Destination = dest.ToString(), Amount = amount, TargetTick = tick,
            InputType = payload.InputType, PayloadHex = Convert.ToHexString(payload.GetPayloadBytes()), Description = desc });
    }

    private async Task Lock()
    {
        _sending = true; _error = null; _result = null;
        try
        {
            if (_lockAmount <= 0) { _error = "Amount must be positive."; return; }
            var tick = await GetTick();
            var payload = new Qubic.Core.Contracts.Qearn.LockPayload();
            await Broadcast(_lockAmount, tick, payload, $"QEarn Lock {_lockAmount:N0} QU");
        }
        catch (Exception ex) { _error = ex.Message; }
        finally { _sending = false; }
    }

    private async Task Unlock()
    {
        _sending = true; _error = null; _result = null;
        try
        {
            if (_unlockAmount <= 0) { _error = "Amount must be positive."; return; }
            var tick = await GetTick();
            var payload = new Qubic.Core.Contracts.Qearn.UnlockPayload
            {
                Amount = (ulong)_unlockAmount, LockedEpoch = _unlockEpoch
            };
            await Broadcast(0, tick, payload, $"QEarn Unlock {_unlockAmount:N0} QU from epoch {_unlockEpoch}");
        }
        catch (Exception ex) { _error = ex.Message; }
        finally { _sending = false; }
    }

    private byte[] GetUserPk()
    {
        var err = IdentityValidation.Validate(_qIdentity);
        if (err != null) throw new Exception("Identity: " + err);
        return Qubic.Core.Entities.QubicIdentity.FromIdentity(_qIdentity!.Trim()).PublicKey;
    }

    private async Task RunQuery()
    {
        _querying = true; _error = null; _queryResult = null; _lockStatusBits = null;
        try
        {
            byte[] input;
            switch (_queryFunc)
            {
                case 1: // GetLockInfoPerEpoch
                    input = new Qubic.Core.Contracts.Qearn.GetLockInfoPerEpochInput { Epoch = _qEpoch }.ToBytes();
                    break;
                case 2: // GetUserLockedInfo
                    input = new Qubic.Core.Contracts.Qearn.GetUserLockedInfoInput { User = GetUserPk(), Epoch = _qEpoch }.ToBytes();
                    break;
                case 3: // GetStateOfRound
                    input = new Qubic.Core.Contracts.Qearn.GetStateOfRoundInput { Epoch = _qEpoch }.ToBytes();
                    break;
                case 4: // GetUserLockStatus
                    input = new Qubic.Core.Contracts.Qearn.GetUserLockStatusInput { User = GetUserPk() }.ToBytes();
                    break;
                case 5: // GetEndedStatus
                    input = new Qubic.Core.Contracts.Qearn.GetEndedStatusInput { User = GetUserPk() }.ToBytes();
                    break;
                case 6: // GetStatsPerEpoch
                    input = new Qubic.Core.Contracts.Qearn.GetStatsPerEpochInput { Epoch = _qEpoch }.ToBytes();
                    break;
                case 7: // GetBurnedAndBoostedStats (empty input)
                    input = [];
                    break;
                case 8: // GetBurnedAndBoostedStatsPerEpoch
                    input = new Qubic.Core.Contracts.Qearn.GetBurnedAndBoostedStatsPerEpochInput { Epoch = _qEpoch }.ToBytes();
                    break;
                default: return;
            }

            var result = await Backend.QuerySmartContractAsync(ContractIndex, (uint)_queryFunc, input);
            _queryResult = ParseQueryResult(_queryFunc, result);
        }
        catch (Exception ex) { _error = ex.Message; }
        finally { _querying = false; }
    }

    private List<KeyValuePair<string, string>> ParseQueryResult(int func, byte[] data)
    {
        var list = new List<KeyValuePair<string, string>>();
        switch (func)
        {
            case 1 when data.Length >= 40:
                var li = Qubic.Core.Contracts.Qearn.GetLockInfoPerEpochOutput.FromBytes(data);
                list.Add(new("Locked Amount", li.LockedAmount.ToString("N0")));
                list.Add(new("Bonus Amount", li.BonusAmount.ToString("N0")));
                list.Add(new("Current Locked Amount", li.CurrentLockedAmount.ToString("N0")));
                list.Add(new("Current Bonus Amount", li.CurrentBonusAmount.ToString("N0")));
                list.Add(new("Yield", li.Yield.ToString("N0")));
                break;

            case 2 when data.Length >= 8:
                var ui = Qubic.Core.Contracts.Qearn.GetUserLockedInfoOutput.FromBytes(data);
                list.Add(new("Locked Amount", ui.LockedAmount.ToString("N0")));
                break;

            case 3 when data.Length >= 4:
                var sr = Qubic.Core.Contracts.Qearn.GetStateOfRoundOutput.FromBytes(data);
                list.Add(new("State", sr.State.ToString()));
                break;

            case 4 when data.Length >= 8:
                var ls = Qubic.Core.Contracts.Qearn.GetUserLockStatusOutput.FromBytes(data);
                _lockStatusBits = ls.Status;
                var lockedCount = 0;
                for (int i = 0; i < 52; i++) if ((ls.Status >> i & 1) == 1) lockedCount++;
                list.Add(new("Status (raw)", ls.Status.ToString()));
                list.Add(new("Locked Weeks", $"{lockedCount} / 52"));
                break;

            case 5 when data.Length >= 32:
                var es = Qubic.Core.Contracts.Qearn.GetEndedStatusOutput.FromBytes(data);
                list.Add(new("Fully Unlocked Amount", es.FullyUnlockedAmount.ToString("N0")));
                list.Add(new("Fully Rewarded Amount", es.FullyRewardedAmount.ToString("N0")));
                list.Add(new("Early Unlocked Amount", es.EarlyUnlockedAmount.ToString("N0")));
                list.Add(new("Early Rewarded Amount", es.EarlyRewardedAmount.ToString("N0")));
                break;

            case 6 when data.Length >= 32:
                var sp = Qubic.Core.Contracts.Qearn.GetStatsPerEpochOutput.FromBytes(data);
                list.Add(new("Early Unlocked Amount", sp.EarlyUnlockedAmount.ToString("N0")));
                list.Add(new("Early Unlocked Percent", sp.EarlyUnlockedPercent.ToString("N0")));
                list.Add(new("Total Locked Amount", sp.TotalLockedAmount.ToString("N0")));
                list.Add(new("Average APY", sp.AverageAPY.ToString("N0")));
                break;

            case 7 when data.Length >= 48:
                var bb = Qubic.Core.Contracts.Qearn.GetBurnedAndBoostedStatsOutput.FromBytes(data);
                list.Add(new("Burned Amount", bb.BurnedAmount.ToString("N0")));
                list.Add(new("Avg Burned %", bb.AverageBurnedPercent.ToString("N0")));
                list.Add(new("Boosted Amount", bb.BoostedAmount.ToString("N0")));
                list.Add(new("Avg Boosted %", bb.AverageBoostedPercent.ToString("N0")));
                list.Add(new("Rewarded Amount", bb.RewardedAmount.ToString("N0")));
                list.Add(new("Avg Rewarded %", bb.AverageRewardedPercent.ToString("N0")));
                break;

            case 8 when data.Length >= 48:
                var bp = Qubic.Core.Contracts.Qearn.GetBurnedAndBoostedStatsPerEpochOutput.FromBytes(data);
                list.Add(new("Burned Amount", bp.BurnedAmount.ToString("N0")));
                list.Add(new("Burned %", bp.BurnedPercent.ToString("N0")));
                list.Add(new("Boosted Amount", bp.BoostedAmount.ToString("N0")));
                list.Add(new("Boosted %", bp.BoostedPercent.ToString("N0")));
                list.Add(new("Rewarded Amount", bp.RewardedAmount.ToString("N0")));
                list.Add(new("Rewarded %", bp.RewardedPercent.ToString("N0")));
                break;

            default:
                list.Add(new("Result", data.Length > 0 ? Convert.ToHexString(data) : "(empty)"));
                break;
        }
        return list;
    }
}
