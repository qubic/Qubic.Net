@page "/contracts/{ContractIndex:int}"
@inject ContractDiscovery Discovery
@inject QubicBackendService Backend
@using Qubic.Core.Entities

<h4>
    <span class="text-muted">[@ContractIndex]</span> @(_contract?.Name ?? "Unknown")
</h4>

@if (_contract == null)
{
    <div class="alert alert-warning">Contract @ContractIndex not found.</div>
    return;
}

<div class="d-flex align-items-center gap-3 mb-3">
    <span class="text-muted">@_contract.Functions.Count function(s)</span>
    <a href="/contracts/browser" class="btn btn-sm btn-outline-secondary">Back to list</a>
</div>

@foreach (var func in _contract.Functions)
{
    var funcKey = func.Name;
    var isExpanded = _expanded.Contains(funcKey);
    var state = _states.GetValueOrDefault(funcKey);

    <div class="card mb-2 fn-card @(func.IsEmptyInput ? "empty-input" : "")">
        <div class="card-header d-flex align-items-center gap-2" style="cursor:pointer"
             @onclick="() => ToggleExpand(funcKey)">
            <span>@(isExpanded ? "\u25BC" : "\u25B6")</span>
            <strong>@func.Name</strong>
            <span class="badge bg-secondary">inputType=@func.InputTypeId</span>
            @if (func.IsEmptyInput)
            {
                <span class="badge bg-success">empty input</span>
            }
            else
            {
                <span class="badge bg-info text-dark">@func.InputProperties.Count param(s)</span>
            }
        </div>

        @if (isExpanded)
        {
            <div class="card-body">
                @if (!func.IsEmptyInput)
                {
                    <div class="mb-3">
                        @foreach (var prop in func.InputProperties)
                        {
                            var formValues = GetFormValues(funcKey);
                            <div class="mb-2">
                                <label class="form-label small mb-0">
                                    @prop.Name
                                    <span class="text-muted">(@GetTypeLabel(prop.PropertyType))</span>
                                </label>
                                @if (prop.PropertyType == typeof(bool))
                                {
                                    <div>
                                        <input type="checkbox" class="form-check-input"
                                               checked="@GetBoolValue(formValues, prop.Name)"
                                               @onchange="@(e => SetFormValue(funcKey, prop.Name, e.Value is true))" />
                                    </div>
                                }
                                else if (prop.PropertyType == typeof(byte[]))
                                {
                                    <input class="form-control form-control-sm mono"
                                           placeholder="60-char identity or hex bytes"
                                           value="@GetStringValue(formValues, prop.Name)"
                                           @onchange="@(e => SetFormValue(funcKey, prop.Name, e.Value?.ToString() ?? ""))" />
                                }
                                else if (IsAssetNameField(prop.Name, prop.PropertyType))
                                {
                                    <input class="form-control form-control-sm mono"
                                           placeholder="e.g. QX, CFB, QUTIL (or number)"
                                           value="@GetStringValue(formValues, prop.Name)"
                                           @onchange="@(e => SetFormValue(funcKey, prop.Name, e.Value?.ToString() ?? ""))" />
                                }
                                else
                                {
                                    <input type="number" class="form-control form-control-sm"
                                           placeholder="0"
                                           value="@GetStringValue(formValues, prop.Name)"
                                           @onchange="@(e => SetFormValue(funcKey, prop.Name, e.Value?.ToString() ?? ""))" />
                                }
                            </div>
                        }
                    </div>
                }

                <button class="btn btn-sm btn-primary" disabled="@(state?.Loading == true)"
                        @onclick="() => CallFunction(func)">
                    @(state?.Loading == true ? "Calling..." : "Call")
                </button>

                @if (state?.Error != null)
                {
                    <div class="alert alert-danger mt-2 mb-0 py-1 px-2 small">@state.Error</div>
                }

                @if (state?.RawOutputHex != null)
                {
                    <div class="mt-2">
                        <div class="small text-muted mb-1">
                            Response: @state.ResponseBytes bytes in @state.ElapsedMs ms
                        </div>
                        <details class="mb-2">
                            <summary class="small text-muted" style="cursor:pointer">Raw hex</summary>
                            <div class="mt-1 p-2 bg-light rounded" style="font-size:0.8em">
                                <div><strong class="text-muted">Input (@((state.RawInputHex?.Length ?? 0) / 2) bytes):</strong></div>
                                <div class="mono" style="word-break:break-all">@(string.IsNullOrEmpty(state.RawInputHex) ? "(empty)" : state.RawInputHex)</div>
                                <div class="mt-1"><strong class="text-muted">Output (@state.ResponseBytes bytes):</strong></div>
                                <div class="mono" style="word-break:break-all">@(state.RawOutputHex.Length > 0 ? state.RawOutputHex : "(empty)")</div>
                            </div>
                        </details>
                    </div>
                }

                @if (state?.OutputProperties != null && state.OutputProperties.Count > 0)
                {
                    <div>
                        <table class="table table-sm table-bordered output-table mb-0">
                            <thead>
                                <tr><th>Property</th><th>Type</th><th>Value</th></tr>
                            </thead>
                            <tbody>
                                @foreach (var (name, value) in state.OutputProperties)
                                {
                                    if (name == "SerializedSize") continue;
                                    var fieldKey = $"{funcKey}.{name}";
                                    var isText = _textFields.Contains(fieldKey);
                                    <tr>
                                        <td>@name</td>
                                        <td class="small">@GetTypeLabel(value?.GetType())</td>
                                        <td class="mono">
                                            @FormatValue(name, value, isText)
                                            @if (value is byte[] { Length: > 0 })
                                            {
                                                <a href="javascript:void(0)" class="ms-2 small text-decoration-none"
                                                   @onclick="() => ToggleTextField(fieldKey)"
                                                   @onclick:preventDefault>@(isText ? "Hex" : "Text")</a>
                                            }
                                        </td>
                                    </tr>
                                }
                            </tbody>
                        </table>
                    </div>
                }

                @if (state?.ArrayDetails != null)
                {
                    @foreach (var (propName, items) in state.ArrayDetails)
                    {
                        var arrayExpanded = _expandedArrays.Contains($"{funcKey}.{propName}");
                        <div class="mt-2">
                            <div class="small" style="cursor:pointer"
                                 @onclick="() => ToggleArrayExpand(funcKey, propName)">
                                <span>@(arrayExpanded ? "\u25BC" : "\u25B6")</span>
                                <strong>@propName</strong> (@items.Count items)
                            </div>
                            @if (arrayExpanded && items.Count > 0)
                            {
                                <table class="table table-sm table-bordered output-table mb-0 ms-3 mt-1" style="font-size:0.85em">
                                    <thead>
                                        <tr>
                                            <th>#</th>
                                            @foreach (var col in items[0].Keys)
                                            {
                                                var colKey = $"{funcKey}.{propName}.{col}";
                                                var hasBytes = items.Any(item => item.TryGetValue(col, out var v) && v is byte[] { Length: > 0 });
                                                <th>
                                                    @col
                                                    @if (hasBytes)
                                                    {
                                                        <a href="javascript:void(0)" class="ms-1 small fw-normal text-decoration-none"
                                                           @onclick="() => ToggleTextField(colKey)"
                                                           @onclick:preventDefault>@(_textFields.Contains(colKey) ? "Hex" : "Text")</a>
                                                    }
                                                </th>
                                            }
                                        </tr>
                                    </thead>
                                    <tbody>
                                        @for (var i = 0; i < items.Count; i++)
                                        {
                                            <tr>
                                                <td>@i</td>
                                                @foreach (var (col, val) in items[i])
                                                {
                                                    var colKey = $"{funcKey}.{propName}.{col}";
                                                    <td class="mono">@FormatValue(col, val, _textFields.Contains(colKey))</td>
                                                }
                                            </tr>
                                        }
                                    </tbody>
                                </table>
                            }
                        </div>
                    }
                }
            </div>
        }
    </div>
}

@code {
    [Parameter] public int ContractIndex { get; set; }

    private ContractInfo? _contract;
    private readonly HashSet<string> _expanded = new();
    private readonly HashSet<string> _expandedArrays = new();
    private readonly Dictionary<string, FunctionCallState> _states = new();
    private readonly Dictionary<string, Dictionary<string, object?>> _formValues = new();
    private readonly HashSet<string> _textFields = new();

    protected override void OnParametersSet()
    {
        _contract = Discovery.Contracts.FirstOrDefault(c => c.ContractIndex == ContractIndex);
    }

    private void ToggleExpand(string funcKey)
    {
        if (!_expanded.Remove(funcKey))
            _expanded.Add(funcKey);
    }

    private void ToggleTextField(string fieldKey)
    {
        if (!_textFields.Remove(fieldKey))
            _textFields.Add(fieldKey);
    }

    private void ToggleArrayExpand(string funcKey, string propName)
    {
        var key = $"{funcKey}.{propName}";
        if (!_expandedArrays.Remove(key))
            _expandedArrays.Add(key);
    }

    private Dictionary<string, object?> GetFormValues(string funcKey)
    {
        if (!_formValues.TryGetValue(funcKey, out var values))
        {
            values = new Dictionary<string, object?>();
            _formValues[funcKey] = values;
        }
        return values;
    }

    private bool GetBoolValue(Dictionary<string, object?> values, string name)
        => values.TryGetValue(name, out var v) && v is true;

    private string GetStringValue(Dictionary<string, object?> values, string name)
        => values.TryGetValue(name, out var v) ? v?.ToString() ?? "" : "";

    private void SetFormValue(string funcKey, string propName, object value)
    {
        GetFormValues(funcKey)[propName] = value;
    }

    private async Task CallFunction(FunctionInfo func)
    {
        var state = new FunctionCallState { Loading = true };
        _states[func.Name] = state;
        StateHasChanged();

        try
        {
            byte[] inputBytes;
            if (func.IsEmptyInput)
            {
                inputBytes = [];
            }
            else
            {
                var formValues = GetFormValues(func.Name);
                var typedValues = new Dictionary<string, object?>();
                foreach (var prop in func.InputProperties)
                {
                    typedValues[prop.Name] = ConvertFormValue(prop, formValues.GetValueOrDefault(prop.Name));
                }
                inputBytes = ContractDiscovery.CreateInputBytes(func.InputType, typedValues);
            }

            state.RawInputHex = Convert.ToHexString(inputBytes).ToLowerInvariant();

            var sw = System.Diagnostics.Stopwatch.StartNew();
            var responseData = await Backend.QuerySmartContractAsync(
                (uint)_contract!.ContractIndex, func.InputTypeId, inputBytes);
            sw.Stop();

            state.ResponseBytes = responseData.Length;
            state.ElapsedMs = sw.ElapsedMilliseconds;
            state.RawOutputHex = Convert.ToHexString(responseData).ToLowerInvariant();

            var output = ContractDiscovery.CallFromBytes(func.OutputType, responseData);
            if (output == null)
            {
                state.Loading = false;
                return;
            }

            var props = ContractDiscovery.ReadOutputProperties(output);
            state.OutputProperties = new Dictionary<string, object?>();
            state.ArrayDetails = new Dictionary<string, List<Dictionary<string, object?>>>();

            foreach (var (name, value) in props)
            {
                if (name == "SerializedSize") continue;

                if (value is Array arr && value is not byte[])
                {
                    state.OutputProperties[name] = $"[{arr.Length} items]";
                    var items = new List<Dictionary<string, object?>>();
                    foreach (var item in arr)
                    {
                        if (item == null) continue;
                        var itemType = item.GetType();
                        if (itemType.IsPrimitive || itemType == typeof(string))
                        {
                            items.Add(new Dictionary<string, object?> { ["Value"] = item });
                        }
                        else
                        {
                            var itemProps = new Dictionary<string, object?>();
                            foreach (var p in itemType.GetProperties(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance))
                            {
                                if (p.Name is "Size" or "SerializedSize") continue;
                                itemProps[p.Name] = p.GetValue(item);
                            }
                            if (itemProps.Count > 0)
                                items.Add(itemProps);
                        }
                    }
                    state.ArrayDetails[name] = items;
                }
                else
                {
                    state.OutputProperties[name] = value;
                }
            }

            state.Loading = false;
        }
        catch (Exception ex)
        {
            state.Error = ex.Message;
            state.Loading = false;
        }
    }

    private static object? ConvertFormValue(InputPropertyInfo prop, object? rawValue)
    {
        if (rawValue == null || (rawValue is string s && string.IsNullOrWhiteSpace(s)))
        {
            if (prop.PropertyType == typeof(byte[]))
                return new byte[32];
            return Activator.CreateInstance(prop.PropertyType);
        }

        var str = rawValue.ToString()!;

        if (prop.PropertyType == typeof(byte[]))
        {
            if (str.Length == 60 && str.All(c => c >= 'A' && c <= 'Z'))
            {
                try { return QubicIdentity.FromIdentity(str).PublicKey; }
                catch { }
            }
            if (str.Length % 2 == 0 && str.All(c => "0123456789abcdefABCDEF".Contains(c)))
            {
                return Convert.FromHexString(str);
            }
            return new byte[32];
        }

        if (prop.PropertyType == typeof(bool))
            return bool.TryParse(str, out var b) && b;

        if (prop.PropertyType == typeof(ulong))
        {
            if (ulong.TryParse(str, out var v))
                return v;
            if (IsAssetNameField(prop.Name, prop.PropertyType) && str.Length <= 7 && str.All(c => c >= ' ' && c <= '~'))
                return AssetNameHelper.ToUlong(str);
            return 0UL;
        }
        if (prop.PropertyType == typeof(long))
            return long.TryParse(str, out var v) ? v : 0L;
        if (prop.PropertyType == typeof(uint))
            return uint.TryParse(str, out var v) ? v : 0U;
        if (prop.PropertyType == typeof(int))
            return int.TryParse(str, out var v) ? v : 0;
        if (prop.PropertyType == typeof(ushort))
            return ushort.TryParse(str, out var v) ? v : (ushort)0;
        if (prop.PropertyType == typeof(short))
            return short.TryParse(str, out var v) ? v : (short)0;
        if (prop.PropertyType == typeof(byte))
            return byte.TryParse(str, out var v) ? v : (byte)0;

        return null;
    }

    private static string GetTypeLabel(Type? type)
    {
        if (type == null) return "null";
        if (type == typeof(byte[])) return "byte[]";
        if (type == typeof(ulong)) return "ulong";
        if (type == typeof(long)) return "long";
        if (type == typeof(uint)) return "uint";
        if (type == typeof(int)) return "int";
        if (type == typeof(ushort)) return "ushort";
        if (type == typeof(short)) return "short";
        if (type == typeof(byte)) return "byte";
        if (type == typeof(bool)) return "bool";
        if (type == typeof(string)) return "string";
        if (type.IsArray) return type.GetElementType()?.Name + "[]";
        return type.Name;
    }

    private static string FormatValue(string name, object? value, bool showText = false)
    {
        if (value == null) return "(null)";

        if (value is byte[] bytes)
        {
            if (bytes.Length == 0) return "(empty)";

            if (showText)
            {
                int len = bytes.Length;
                while (len > 0 && bytes[len - 1] == 0) len--;
                if (len == 0) return "(empty)";
                return System.Text.Encoding.ASCII.GetString(bytes, 0, len)
                    .Replace("\0", "");
            }

            if (bytes.Length == 32)
            {
                try { return QubicIdentity.FromPublicKey(bytes).Identity; }
                catch { }
            }
            if (bytes.Length <= 64) return Convert.ToHexString(bytes).ToLowerInvariant();
            return Convert.ToHexString(bytes[..32]).ToLowerInvariant() + $"... ({bytes.Length} bytes)";
        }

        if (value is string s) return s;

        if (value is ulong ul && ul != 0 && IsAssetNameField(name, typeof(ulong)))
        {
            var decoded = AssetNameHelper.FromUlong(ul);
            if (decoded != null) return $"{ul} ({decoded})";
        }

        return value.ToString() ?? "(null)";
    }

    private static bool IsAssetNameField(string name, Type type)
    {
        if (type != typeof(ulong)) return false;
        var lower = name.ToLowerInvariant();
        return lower.Contains("assetname") || lower.Contains("unitofmeasurement");
    }



    private class FunctionCallState
    {
        public bool Loading { get; set; }
        public string? Error { get; set; }
        public int ResponseBytes { get; set; }
        public long ElapsedMs { get; set; }
        public string? RawInputHex { get; set; }
        public string? RawOutputHex { get; set; }
        public Dictionary<string, object?>? OutputProperties { get; set; }
        public Dictionary<string, List<Dictionary<string, object?>>>? ArrayDetails { get; set; }
    }
}
