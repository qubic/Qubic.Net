// <auto-generated>
// Generated by Qubic.ContractGen from QIP.h.
// Do not edit manually. Re-run the generator after updating deps/qubic-core.
// </auto-generated>

using System.Buffers.Binary;
using Qubic.Core.Contracts;
using Qubic.Core.Payloads;

namespace Qubic.Core.Contracts.Qip;

/// <summary>Qip contract (index 18).</summary>
public static class QipContract
{
    /// <summary>Contract index on the Qubic network.</summary>
    public const int ContractIndex = 18;

    /// <summary>Gets the 32-byte contract public key.</summary>
    public static byte[] GetPublicKey() => QubicContracts.GetContractPublicKey(ContractIndex);

    /// <summary>Read-only query function IDs.</summary>
    public static class Functions
    {
        /// <summary>getICOInfo (inputType=1).</summary>
        public const uint GetICOInfo = 1;
    }

    /// <summary>State-mutating procedure IDs.</summary>
    public static class Procedures
    {
        /// <summary>createICO (inputType=1).</summary>
        public const uint CreateICO = 1;
        /// <summary>buyToken (inputType=2).</summary>
        public const uint BuyToken = 2;
        /// <summary>TransferShareManagementRights (inputType=3).</summary>
        public const uint TransferShareManagementRights = 3;
    }
}

// ═══ Function: getICOInfo (inputType=1) ═══

/// <summary>Input for query.</summary>
public readonly struct GetICOInfoInput : ISmartContractInput
{
    public const int Size = 4;

    public int SerializedSize => Size;

    public uint IndexOfICO { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), IndexOfICO);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetICOInfoOutput : ISmartContractOutput<GetICOInfoOutput>
{
    public byte[] CreatorOfICO { get; init; }
    public byte[] Issuer { get; init; }
    public byte[] Address1 { get; init; }
    public byte[] Address2 { get; init; }
    public byte[] Address3 { get; init; }
    public byte[] Address4 { get; init; }
    public byte[] Address5 { get; init; }
    public byte[] Address6 { get; init; }
    public byte[] Address7 { get; init; }
    public byte[] Address8 { get; init; }
    public byte[] Address9 { get; init; }
    public byte[] Address10 { get; init; }
    public ulong AssetName { get; init; }
    public ulong Price1 { get; init; }
    public ulong Price2 { get; init; }
    public ulong Price3 { get; init; }
    public ulong SaleAmountForPhase1 { get; init; }
    public ulong SaleAmountForPhase2 { get; init; }
    public ulong SaleAmountForPhase3 { get; init; }
    public ulong RemainingAmountForPhase1 { get; init; }
    public ulong RemainingAmountForPhase2 { get; init; }
    public ulong RemainingAmountForPhase3 { get; init; }
    public uint Percent1 { get; init; }
    public uint Percent2 { get; init; }
    public uint Percent3 { get; init; }
    public uint Percent4 { get; init; }
    public uint Percent5 { get; init; }
    public uint Percent6 { get; init; }
    public uint Percent7 { get; init; }
    public uint Percent8 { get; init; }
    public uint Percent9 { get; init; }
    public uint Percent10 { get; init; }
    public uint StartEpoch { get; init; }

    public static GetICOInfoOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetICOInfoOutput
        {
            CreatorOfICO = data[0..].Slice(0, 32).ToArray(),
            Issuer = data[32..].Slice(0, 32).ToArray(),
            Address1 = data[64..].Slice(0, 32).ToArray(),
            Address2 = data[96..].Slice(0, 32).ToArray(),
            Address3 = data[128..].Slice(0, 32).ToArray(),
            Address4 = data[160..].Slice(0, 32).ToArray(),
            Address5 = data[192..].Slice(0, 32).ToArray(),
            Address6 = data[224..].Slice(0, 32).ToArray(),
            Address7 = data[256..].Slice(0, 32).ToArray(),
            Address8 = data[288..].Slice(0, 32).ToArray(),
            Address9 = data[320..].Slice(0, 32).ToArray(),
            Address10 = data[352..].Slice(0, 32).ToArray(),
            AssetName = BinaryPrimitives.ReadUInt64LittleEndian(data[384..]),
            Price1 = BinaryPrimitives.ReadUInt64LittleEndian(data[392..]),
            Price2 = BinaryPrimitives.ReadUInt64LittleEndian(data[400..]),
            Price3 = BinaryPrimitives.ReadUInt64LittleEndian(data[408..]),
            SaleAmountForPhase1 = BinaryPrimitives.ReadUInt64LittleEndian(data[416..]),
            SaleAmountForPhase2 = BinaryPrimitives.ReadUInt64LittleEndian(data[424..]),
            SaleAmountForPhase3 = BinaryPrimitives.ReadUInt64LittleEndian(data[432..]),
            RemainingAmountForPhase1 = BinaryPrimitives.ReadUInt64LittleEndian(data[440..]),
            RemainingAmountForPhase2 = BinaryPrimitives.ReadUInt64LittleEndian(data[448..]),
            RemainingAmountForPhase3 = BinaryPrimitives.ReadUInt64LittleEndian(data[456..]),
            Percent1 = BinaryPrimitives.ReadUInt32LittleEndian(data[464..]),
            Percent2 = BinaryPrimitives.ReadUInt32LittleEndian(data[468..]),
            Percent3 = BinaryPrimitives.ReadUInt32LittleEndian(data[472..]),
            Percent4 = BinaryPrimitives.ReadUInt32LittleEndian(data[476..]),
            Percent5 = BinaryPrimitives.ReadUInt32LittleEndian(data[480..]),
            Percent6 = BinaryPrimitives.ReadUInt32LittleEndian(data[484..]),
            Percent7 = BinaryPrimitives.ReadUInt32LittleEndian(data[488..]),
            Percent8 = BinaryPrimitives.ReadUInt32LittleEndian(data[492..]),
            Percent9 = BinaryPrimitives.ReadUInt32LittleEndian(data[496..]),
            Percent10 = BinaryPrimitives.ReadUInt32LittleEndian(data[500..]),
            StartEpoch = BinaryPrimitives.ReadUInt32LittleEndian(data[504..])
        };
    }
}

// ═══ Procedure: createICO (inputType=1) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class CreateICOPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 456;

    public ushort InputType => 1;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] Issuer { get; init; }
    public required byte[] Address1 { get; init; }
    public required byte[] Address2 { get; init; }
    public required byte[] Address3 { get; init; }
    public required byte[] Address4 { get; init; }
    public required byte[] Address5 { get; init; }
    public required byte[] Address6 { get; init; }
    public required byte[] Address7 { get; init; }
    public required byte[] Address8 { get; init; }
    public required byte[] Address9 { get; init; }
    public required byte[] Address10 { get; init; }
    public ulong AssetName { get; init; }
    public ulong Price1 { get; init; }
    public ulong Price2 { get; init; }
    public ulong Price3 { get; init; }
    public ulong SaleAmountForPhase1 { get; init; }
    public ulong SaleAmountForPhase2 { get; init; }
    public ulong SaleAmountForPhase3 { get; init; }
    public uint Percent1 { get; init; }
    public uint Percent2 { get; init; }
    public uint Percent3 { get; init; }
    public uint Percent4 { get; init; }
    public uint Percent5 { get; init; }
    public uint Percent6 { get; init; }
    public uint Percent7 { get; init; }
    public uint Percent8 { get; init; }
    public uint Percent9 { get; init; }
    public uint Percent10 { get; init; }
    public uint StartEpoch { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Issuer.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        Address1.AsSpan(0, 32).CopyTo(bytes.AsSpan(32));
        Address2.AsSpan(0, 32).CopyTo(bytes.AsSpan(64));
        Address3.AsSpan(0, 32).CopyTo(bytes.AsSpan(96));
        Address4.AsSpan(0, 32).CopyTo(bytes.AsSpan(128));
        Address5.AsSpan(0, 32).CopyTo(bytes.AsSpan(160));
        Address6.AsSpan(0, 32).CopyTo(bytes.AsSpan(192));
        Address7.AsSpan(0, 32).CopyTo(bytes.AsSpan(224));
        Address8.AsSpan(0, 32).CopyTo(bytes.AsSpan(256));
        Address9.AsSpan(0, 32).CopyTo(bytes.AsSpan(288));
        Address10.AsSpan(0, 32).CopyTo(bytes.AsSpan(320));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(352), AssetName);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(360), Price1);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(368), Price2);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(376), Price3);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(384), SaleAmountForPhase1);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(392), SaleAmountForPhase2);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(400), SaleAmountForPhase3);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(408), Percent1);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(412), Percent2);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(416), Percent3);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(420), Percent4);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(424), Percent5);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(428), Percent6);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(432), Percent7);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(436), Percent8);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(440), Percent9);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(444), Percent10);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(448), StartEpoch);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct CreateICOOutput : ISmartContractOutput<CreateICOOutput>
{
    public int ReturnCode { get; init; }

    public static CreateICOOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new CreateICOOutput
        {
            ReturnCode = BinaryPrimitives.ReadInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: buyToken (inputType=2) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class BuyTokenPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 16;

    public ushort InputType => 2;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public uint IndexOfICO { get; init; }
    public ulong Amount { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), IndexOfICO);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(8), Amount);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct BuyTokenOutput : ISmartContractOutput<BuyTokenOutput>
{
    public int ReturnCode { get; init; }

    public static BuyTokenOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new BuyTokenOutput
        {
            ReturnCode = BinaryPrimitives.ReadInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: TransferShareManagementRights (inputType=3) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class TransferShareManagementRightsPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 56;

    public ushort InputType => 3;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required QubicAsset Asset { get; init; }
    public long NumberOfShares { get; init; }
    public uint NewManagingContractIndex { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Asset.WriteTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(40), NumberOfShares);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(48), NewManagingContractIndex);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct TransferShareManagementRightsOutput : ISmartContractOutput<TransferShareManagementRightsOutput>
{
    public long TransferredNumberOfShares { get; init; }

    public static TransferShareManagementRightsOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new TransferShareManagementRightsOutput
        {
            TransferredNumberOfShares = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}
