// <auto-generated>
// Generated by Qubic.ContractGen from QBond.h.
// Do not edit manually. Re-run the generator after updating deps/qubic-core.
// </auto-generated>

using System.Buffers.Binary;
using Qubic.Core.Contracts;
using Qubic.Core.Payloads;

namespace Qubic.Core.Contracts.Qbond;

/// <summary>Qbond contract (index 17).</summary>
public static class QbondContract
{
    /// <summary>Contract index on the Qubic network.</summary>
    public const int ContractIndex = 17;

    /// <summary>Gets the 32-byte contract public key.</summary>
    public static byte[] GetPublicKey() => QubicContracts.GetContractPublicKey(ContractIndex);

    /// <summary>Read-only query function IDs.</summary>
    public static class Functions
    {
        /// <summary>GetFees (inputType=1).</summary>
        public const uint GetFees = 1;
        /// <summary>GetEarnedFees (inputType=2).</summary>
        public const uint GetEarnedFees = 2;
        /// <summary>GetInfoPerEpoch (inputType=3).</summary>
        public const uint GetInfoPerEpoch = 3;
        /// <summary>GetOrders (inputType=4).</summary>
        public const uint GetOrders = 4;
        /// <summary>GetUserOrders (inputType=5).</summary>
        public const uint GetUserOrders = 5;
        /// <summary>GetMBondsTable (inputType=6).</summary>
        public const uint GetMBondsTable = 6;
        /// <summary>GetUserMBonds (inputType=7).</summary>
        public const uint GetUserMBonds = 7;
        /// <summary>GetCFA (inputType=8).</summary>
        public const uint GetCFA = 8;
    }

    /// <summary>State-mutating procedure IDs.</summary>
    public static class Procedures
    {
        /// <summary>Stake (inputType=1).</summary>
        public const uint Stake = 1;
        /// <summary>TransferMBondOwnershipAndPossession (inputType=2).</summary>
        public const uint TransferMBondOwnershipAndPossession = 2;
        /// <summary>AddAskOrder (inputType=3).</summary>
        public const uint AddAskOrder = 3;
        /// <summary>RemoveAskOrder (inputType=4).</summary>
        public const uint RemoveAskOrder = 4;
        /// <summary>AddBidOrder (inputType=5).</summary>
        public const uint AddBidOrder = 5;
        /// <summary>RemoveBidOrder (inputType=6).</summary>
        public const uint RemoveBidOrder = 6;
        /// <summary>BurnQU (inputType=7).</summary>
        public const uint BurnQU = 7;
        /// <summary>UpdateCFA (inputType=8).</summary>
        public const uint UpdateCFA = 8;
    }
}

// ═══ Function: GetFees (inputType=1) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetFeesInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetFeesOutput : ISmartContractOutput<GetFeesOutput>
{
    public ulong StakeFeePercent { get; init; }
    public ulong TradeFeePercent { get; init; }
    public ulong TransferFee { get; init; }

    public static GetFeesOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetFeesOutput
        {
            StakeFeePercent = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            TradeFeePercent = BinaryPrimitives.ReadUInt64LittleEndian(data[8..]),
            TransferFee = BinaryPrimitives.ReadUInt64LittleEndian(data[16..])
        };
    }
}

// ═══ Function: GetEarnedFees (inputType=2) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetEarnedFeesInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetEarnedFeesOutput : ISmartContractOutput<GetEarnedFeesOutput>
{
    public ulong StakeFees { get; init; }
    public ulong TradeFees { get; init; }

    public static GetEarnedFeesOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetEarnedFeesOutput
        {
            StakeFees = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            TradeFees = BinaryPrimitives.ReadUInt64LittleEndian(data[8..])
        };
    }
}

// ═══ Function: GetInfoPerEpoch (inputType=3) ═══

/// <summary>Input for query.</summary>
public readonly struct GetInfoPerEpochInput : ISmartContractInput
{
    public const int Size = 8;

    public int SerializedSize => Size;

    public long Epoch { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(0), Epoch);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetInfoPerEpochOutput : ISmartContractOutput<GetInfoPerEpochOutput>
{
    public ulong StakersAmount { get; init; }
    public long TotalStaked { get; init; }
    public long Apy { get; init; }

    public static GetInfoPerEpochOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetInfoPerEpochOutput
        {
            StakersAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            TotalStaked = BinaryPrimitives.ReadInt64LittleEndian(data[8..]),
            Apy = BinaryPrimitives.ReadInt64LittleEndian(data[16..])
        };
    }
}

// ═══ Function: GetOrders (inputType=4) ═══

/// <summary>Nested type from GetOrders.</summary>
public readonly struct GetOrdersOrder
{
    public const int Size = 56;

    public required byte[] Owner { get; init; }
    public long Epoch { get; init; }
    public long NumberOfMBonds { get; init; }
    public long Price { get; init; }

    public static GetOrdersOrder ReadFrom(ReadOnlySpan<byte> data)
    {
        return new GetOrdersOrder
        {
            Owner = data[0..].Slice(0, 32).ToArray(),
            Epoch = BinaryPrimitives.ReadInt64LittleEndian(data[32..]),
            NumberOfMBonds = BinaryPrimitives.ReadInt64LittleEndian(data[40..]),
            Price = BinaryPrimitives.ReadInt64LittleEndian(data[48..])
        };
    }
}

/// <summary>Input for query.</summary>
public readonly struct GetOrdersInput : ISmartContractInput
{
    public const int Size = 24;

    public int SerializedSize => Size;

    public long Epoch { get; init; }
    public long AskOrdersOffset { get; init; }
    public long BidOrdersOffset { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(0), Epoch);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(8), AskOrdersOffset);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(16), BidOrdersOffset);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetOrdersOutput : ISmartContractOutput<GetOrdersOutput>
{
    public GetOrdersOrder[] AskOrders { get; init; }
    public GetOrdersOrder[] BidOrders { get; init; }

    public static GetOrdersOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var askOrders = new GetOrdersOrder[256];
        for (int i = 0; i < 256; i++)
        {
            askOrders[i] = GetOrdersOrder.ReadFrom(data.Slice(0 + i * GetOrdersOrder.Size, GetOrdersOrder.Size));
        }
        var bidOrders = new GetOrdersOrder[256];
        for (int i = 0; i < 256; i++)
        {
            bidOrders[i] = GetOrdersOrder.ReadFrom(data.Slice(14336 + i * GetOrdersOrder.Size, GetOrdersOrder.Size));
        }
        return new GetOrdersOutput
        {
            AskOrders = askOrders,
            BidOrders = bidOrders
        };
    }
}

// ═══ Function: GetUserOrders (inputType=5) ═══

/// <summary>Nested type from GetUserOrders.</summary>
public readonly struct GetUserOrdersOrder
{
    public const int Size = 56;

    public required byte[] Owner { get; init; }
    public long Epoch { get; init; }
    public long NumberOfMBonds { get; init; }
    public long Price { get; init; }

    public static GetUserOrdersOrder ReadFrom(ReadOnlySpan<byte> data)
    {
        return new GetUserOrdersOrder
        {
            Owner = data[0..].Slice(0, 32).ToArray(),
            Epoch = BinaryPrimitives.ReadInt64LittleEndian(data[32..]),
            NumberOfMBonds = BinaryPrimitives.ReadInt64LittleEndian(data[40..]),
            Price = BinaryPrimitives.ReadInt64LittleEndian(data[48..])
        };
    }
}

/// <summary>Input for query.</summary>
public readonly struct GetUserOrdersInput : ISmartContractInput
{
    public const int Size = 48;

    public int SerializedSize => Size;

    public required byte[] Owner { get; init; }
    public long AskOrdersOffset { get; init; }
    public long BidOrdersOffset { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Owner.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(32), AskOrdersOffset);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(40), BidOrdersOffset);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetUserOrdersOutput : ISmartContractOutput<GetUserOrdersOutput>
{
    public GetUserOrdersOrder[] AskOrders { get; init; }
    public GetUserOrdersOrder[] BidOrders { get; init; }

    public static GetUserOrdersOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var askOrders = new GetUserOrdersOrder[256];
        for (int i = 0; i < 256; i++)
        {
            askOrders[i] = GetUserOrdersOrder.ReadFrom(data.Slice(0 + i * GetUserOrdersOrder.Size, GetUserOrdersOrder.Size));
        }
        var bidOrders = new GetUserOrdersOrder[256];
        for (int i = 0; i < 256; i++)
        {
            bidOrders[i] = GetUserOrdersOrder.ReadFrom(data.Slice(14336 + i * GetUserOrdersOrder.Size, GetUserOrdersOrder.Size));
        }
        return new GetUserOrdersOutput
        {
            AskOrders = askOrders,
            BidOrders = bidOrders
        };
    }
}

// ═══ Function: GetMBondsTable (inputType=6) ═══

/// <summary>Nested type from GetMBondsTable.</summary>
public readonly struct GetMBondsTableTableEntry
{
    public const int Size = 32;

    public long Epoch { get; init; }
    public long TotalStakedQBond { get; init; }
    public long TotalStakedQEarn { get; init; }
    public ulong Apy { get; init; }

    public static GetMBondsTableTableEntry ReadFrom(ReadOnlySpan<byte> data)
    {
        return new GetMBondsTableTableEntry
        {
            Epoch = BinaryPrimitives.ReadInt64LittleEndian(data[0..]),
            TotalStakedQBond = BinaryPrimitives.ReadInt64LittleEndian(data[8..]),
            TotalStakedQEarn = BinaryPrimitives.ReadInt64LittleEndian(data[16..]),
            Apy = BinaryPrimitives.ReadUInt64LittleEndian(data[24..])
        };
    }
}

/// <summary>Input for query (empty).</summary>
public readonly struct GetMBondsTableInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetMBondsTableOutput : ISmartContractOutput<GetMBondsTableOutput>
{
    public GetMBondsTableTableEntry[] Info { get; init; }

    public static GetMBondsTableOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var info = new GetMBondsTableTableEntry[512];
        for (int i = 0; i < 512; i++)
        {
            info[i] = GetMBondsTableTableEntry.ReadFrom(data.Slice(0 + i * GetMBondsTableTableEntry.Size, GetMBondsTableTableEntry.Size));
        }
        return new GetMBondsTableOutput
        {
            Info = info
        };
    }
}

// ═══ Function: GetUserMBonds (inputType=7) ═══

/// <summary>Nested type from GetUserMBonds.</summary>
public readonly struct GetUserMBondsMBondEntity
{
    public const int Size = 24;

    public long Epoch { get; init; }
    public long Amount { get; init; }
    public ulong Apy { get; init; }

    public static GetUserMBondsMBondEntity ReadFrom(ReadOnlySpan<byte> data)
    {
        return new GetUserMBondsMBondEntity
        {
            Epoch = BinaryPrimitives.ReadInt64LittleEndian(data[0..]),
            Amount = BinaryPrimitives.ReadInt64LittleEndian(data[8..]),
            Apy = BinaryPrimitives.ReadUInt64LittleEndian(data[16..])
        };
    }
}

/// <summary>Input for query.</summary>
public readonly struct GetUserMBondsInput : ISmartContractInput
{
    public const int Size = 32;

    public int SerializedSize => Size;

    public required byte[] Owner { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Owner.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetUserMBondsOutput : ISmartContractOutput<GetUserMBondsOutput>
{
    public long TotalMBondsAmount { get; init; }
    public GetUserMBondsMBondEntity[] Mbonds { get; init; }

    public static GetUserMBondsOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var mbonds = new GetUserMBondsMBondEntity[256];
        for (int i = 0; i < 256; i++)
        {
            mbonds[i] = GetUserMBondsMBondEntity.ReadFrom(data.Slice(8 + i * GetUserMBondsMBondEntity.Size, GetUserMBondsMBondEntity.Size));
        }
        return new GetUserMBondsOutput
        {
            TotalMBondsAmount = BinaryPrimitives.ReadInt64LittleEndian(data[0..]),
            Mbonds = mbonds
        };
    }
}

// ═══ Function: GetCFA (inputType=8) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetCFAInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetCFAOutput : ISmartContractOutput<GetCFAOutput>
{
    public byte[][] CommissionFreeAddresses { get; init; }

    public static GetCFAOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var commissionFreeAddresses = new byte[1024][];
        for (int i = 0; i < 1024; i++)
        {
            commissionFreeAddresses[i] = data[(0 + i * 32)..].Slice(0, 32).ToArray();
        }
        return new GetCFAOutput
        {
            CommissionFreeAddresses = commissionFreeAddresses
        };
    }
}

// ═══ Procedure: Stake (inputType=1) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class StakePayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 8;

    public ushort InputType => 1;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public long QuMillions { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(0), QuMillions);
        return bytes;
    }
}

/// <summary>Output (empty).</summary>
public readonly struct StakeOutput : ISmartContractOutput<StakeOutput>
{
    public static StakeOutput FromBytes(ReadOnlySpan<byte> data) => new();
}

// ═══ Procedure: TransferMBondOwnershipAndPossession (inputType=2) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class TransferMBondOwnershipAndPossessionPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 48;

    public ushort InputType => 2;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] NewOwnerAndPossessor { get; init; }
    public long Epoch { get; init; }
    public long NumberOfMBonds { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        NewOwnerAndPossessor.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(32), Epoch);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(40), NumberOfMBonds);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct TransferMBondOwnershipAndPossessionOutput : ISmartContractOutput<TransferMBondOwnershipAndPossessionOutput>
{
    public long TransferredMBonds { get; init; }

    public static TransferMBondOwnershipAndPossessionOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new TransferMBondOwnershipAndPossessionOutput
        {
            TransferredMBonds = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: AddAskOrder (inputType=3) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class AddAskOrderPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 24;

    public ushort InputType => 3;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public long Epoch { get; init; }
    public long Price { get; init; }
    public long NumberOfMBonds { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(0), Epoch);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(8), Price);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(16), NumberOfMBonds);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct AddAskOrderOutput : ISmartContractOutput<AddAskOrderOutput>
{
    public long AddedMBondsAmount { get; init; }

    public static AddAskOrderOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new AddAskOrderOutput
        {
            AddedMBondsAmount = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: RemoveAskOrder (inputType=4) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class RemoveAskOrderPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 24;

    public ushort InputType => 4;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public long Epoch { get; init; }
    public long Price { get; init; }
    public long NumberOfMBonds { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(0), Epoch);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(8), Price);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(16), NumberOfMBonds);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct RemoveAskOrderOutput : ISmartContractOutput<RemoveAskOrderOutput>
{
    public long RemovedMBondsAmount { get; init; }

    public static RemoveAskOrderOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new RemoveAskOrderOutput
        {
            RemovedMBondsAmount = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: AddBidOrder (inputType=5) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class AddBidOrderPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 24;

    public ushort InputType => 5;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public long Epoch { get; init; }
    public long Price { get; init; }
    public long NumberOfMBonds { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(0), Epoch);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(8), Price);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(16), NumberOfMBonds);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct AddBidOrderOutput : ISmartContractOutput<AddBidOrderOutput>
{
    public long AddedMBondsAmount { get; init; }

    public static AddBidOrderOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new AddBidOrderOutput
        {
            AddedMBondsAmount = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: RemoveBidOrder (inputType=6) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class RemoveBidOrderPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 24;

    public ushort InputType => 6;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public long Epoch { get; init; }
    public long Price { get; init; }
    public long NumberOfMBonds { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(0), Epoch);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(8), Price);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(16), NumberOfMBonds);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct RemoveBidOrderOutput : ISmartContractOutput<RemoveBidOrderOutput>
{
    public long RemovedMBondsAmount { get; init; }

    public static RemoveBidOrderOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new RemoveBidOrderOutput
        {
            RemovedMBondsAmount = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: BurnQU (inputType=7) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class BurnQUPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 8;

    public ushort InputType => 7;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public long Amount { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(0), Amount);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct BurnQUOutput : ISmartContractOutput<BurnQUOutput>
{
    public long Amount { get; init; }

    public static BurnQUOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new BurnQUOutput
        {
            Amount = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: UpdateCFA (inputType=8) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class UpdateCFAPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 40;

    public ushort InputType => 8;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] User { get; init; }
    public bool Operation { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        User.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        bytes.AsSpan(32, 1)[0] = (byte)(Operation ? 1 : 0);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct UpdateCFAOutput : ISmartContractOutput<UpdateCFAOutput>
{
    public bool Result { get; init; }

    public static UpdateCFAOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new UpdateCFAOutput
        {
            Result = (data.Slice(0, 1)[0] != 0)
        };
    }
}
