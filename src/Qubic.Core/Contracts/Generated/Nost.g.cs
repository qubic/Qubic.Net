// <auto-generated>
// Generated by Qubic.ContractGen from Nostromo.h.
// Do not edit manually. Re-run the generator after updating deps/qubic-core.
// </auto-generated>

using System.Buffers.Binary;
using Qubic.Core.Contracts;
using Qubic.Core.Payloads;

namespace Qubic.Core.Contracts.Nost;

/// <summary>Nost contract (index 14).</summary>
public static class NostContract
{
    /// <summary>Contract index on the Qubic network.</summary>
    public const int ContractIndex = 14;

    /// <summary>Gets the 32-byte contract public key.</summary>
    public static byte[] GetPublicKey() => QubicContracts.GetContractPublicKey(ContractIndex);

    /// <summary>Read-only query function IDs.</summary>
    public static class Functions
    {
        /// <summary>getStats (inputType=1).</summary>
        public const uint GetStats = 1;
        /// <summary>getTierLevelByUser (inputType=2).</summary>
        public const uint GetTierLevelByUser = 2;
        /// <summary>getUserVoteStatus (inputType=3).</summary>
        public const uint GetUserVoteStatus = 3;
        /// <summary>checkTokenCreatability (inputType=4).</summary>
        public const uint CheckTokenCreatability = 4;
        /// <summary>getNumberOfInvestedProjects (inputType=5).</summary>
        public const uint GetNumberOfInvestedProjects = 5;
        /// <summary>getProjectByIndex (inputType=6).</summary>
        public const uint GetProjectByIndex = 6;
        /// <summary>getFundarasingByIndex (inputType=7).</summary>
        public const uint GetFundarasingByIndex = 7;
        /// <summary>getProjectIndexListByCreator (inputType=8).</summary>
        public const uint GetProjectIndexListByCreator = 8;
        /// <summary>getInfoUserInvested (inputType=9).</summary>
        public const uint GetInfoUserInvested = 9;
        /// <summary>getMaxClaimAmount (inputType=10).</summary>
        public const uint GetMaxClaimAmount = 10;
    }

    /// <summary>State-mutating procedure IDs.</summary>
    public static class Procedures
    {
        /// <summary>registerInTier (inputType=1).</summary>
        public const uint RegisterInTier = 1;
        /// <summary>logoutFromTier (inputType=2).</summary>
        public const uint LogoutFromTier = 2;
        /// <summary>createProject (inputType=3).</summary>
        public const uint CreateProject = 3;
        /// <summary>voteInProject (inputType=4).</summary>
        public const uint VoteInProject = 4;
        /// <summary>createFundraising (inputType=5).</summary>
        public const uint CreateFundraising = 5;
        /// <summary>investInProject (inputType=6).</summary>
        public const uint InvestInProject = 6;
        /// <summary>claimToken (inputType=7).</summary>
        public const uint ClaimToken = 7;
        /// <summary>upgradeTier (inputType=8).</summary>
        public const uint UpgradeTier = 8;
        /// <summary>TransferShareManagementRights (inputType=9).</summary>
        public const uint TransferShareManagementRights = 9;
    }
}

// ═══ Function: getStats (inputType=1) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetStatsInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetStatsOutput : ISmartContractOutput<GetStatsOutput>
{
    public ulong EpochRevenue { get; init; }
    public ulong TotalPoolWeight { get; init; }
    public uint NumberOfRegister { get; init; }
    public uint NumberOfCreatedProject { get; init; }
    public uint NumberOfFundraising { get; init; }

    public static GetStatsOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetStatsOutput
        {
            EpochRevenue = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            TotalPoolWeight = BinaryPrimitives.ReadUInt64LittleEndian(data[8..]),
            NumberOfRegister = BinaryPrimitives.ReadUInt32LittleEndian(data[16..]),
            NumberOfCreatedProject = BinaryPrimitives.ReadUInt32LittleEndian(data[20..]),
            NumberOfFundraising = BinaryPrimitives.ReadUInt32LittleEndian(data[24..])
        };
    }
}

// ═══ Function: getTierLevelByUser (inputType=2) ═══

/// <summary>Input for query.</summary>
public readonly struct GetTierLevelByUserInput : ISmartContractInput
{
    public const int Size = 32;

    public int SerializedSize => Size;

    public required byte[] UserId { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        UserId.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetTierLevelByUserOutput : ISmartContractOutput<GetTierLevelByUserOutput>
{
    public byte TierLevel { get; init; }

    public static GetTierLevelByUserOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetTierLevelByUserOutput
        {
            TierLevel = data.Slice(0, 1)[0]
        };
    }
}

// ═══ Function: getUserVoteStatus (inputType=3) ═══

/// <summary>Input for query.</summary>
public readonly struct GetUserVoteStatusInput : ISmartContractInput
{
    public const int Size = 32;

    public int SerializedSize => Size;

    public required byte[] UserId { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        UserId.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetUserVoteStatusOutput : ISmartContractOutput<GetUserVoteStatusOutput>
{
    public uint NumberOfVotedProjects { get; init; }
    public uint[] ProjectIndexList { get; init; }

    public static GetUserVoteStatusOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var projectIndexList = new uint[0];
        for (int i = 0; i < 0; i++)
        {
            projectIndexList[i] = BinaryPrimitives.ReadUInt32LittleEndian(data[(4 + i * 4)..]);
        }
        return new GetUserVoteStatusOutput
        {
            NumberOfVotedProjects = BinaryPrimitives.ReadUInt32LittleEndian(data[0..]),
            ProjectIndexList = projectIndexList
        };
    }
}

// ═══ Function: checkTokenCreatability (inputType=4) ═══

/// <summary>Input for query.</summary>
public readonly struct CheckTokenCreatabilityInput : ISmartContractInput
{
    public const int Size = 8;

    public int SerializedSize => Size;

    public ulong TokenName { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), TokenName);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct CheckTokenCreatabilityOutput : ISmartContractOutput<CheckTokenCreatabilityOutput>
{
    public bool Result { get; init; }

    public static CheckTokenCreatabilityOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new CheckTokenCreatabilityOutput
        {
            Result = (data.Slice(0, 1)[0] != 0)
        };
    }
}

// ═══ Function: getNumberOfInvestedProjects (inputType=5) ═══

/// <summary>Input for query.</summary>
public readonly struct GetNumberOfInvestedProjectsInput : ISmartContractInput
{
    public const int Size = 32;

    public int SerializedSize => Size;

    public required byte[] UserId { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        UserId.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetNumberOfInvestedProjectsOutput : ISmartContractOutput<GetNumberOfInvestedProjectsOutput>
{
    public uint NumberOfInvestedProjects { get; init; }

    public static GetNumberOfInvestedProjectsOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetNumberOfInvestedProjectsOutput
        {
            NumberOfInvestedProjects = BinaryPrimitives.ReadUInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Function: getProjectByIndex (inputType=6) ═══

/// <summary>Input for query.</summary>
public readonly struct GetProjectByIndexInput : ISmartContractInput
{
    public const int Size = 4;

    public int SerializedSize => Size;

    public uint IndexOfProject { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), IndexOfProject);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetProjectByIndexOutput : ISmartContractOutput<GetProjectByIndexOutput>
{
    public byte[] Project { get; init; }

    public static GetProjectByIndexOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetProjectByIndexOutput
        {
            Project = [] /* unknown type projectInfo */
        };
    }
}

// ═══ Function: getFundarasingByIndex (inputType=7) ═══

/// <summary>Input for query.</summary>
public readonly struct GetFundarasingByIndexInput : ISmartContractInput
{
    public const int Size = 4;

    public int SerializedSize => Size;

    public uint IndexOfFundarasing { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), IndexOfFundarasing);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetFundarasingByIndexOutput : ISmartContractOutput<GetFundarasingByIndexOutput>
{
    public byte[] Fundarasing { get; init; }

    public static GetFundarasingByIndexOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetFundarasingByIndexOutput
        {
            Fundarasing = [] /* unknown type fundaraisingInfo */
        };
    }
}

// ═══ Function: getProjectIndexListByCreator (inputType=8) ═══

/// <summary>Input for query.</summary>
public readonly struct GetProjectIndexListByCreatorInput : ISmartContractInput
{
    public const int Size = 32;

    public int SerializedSize => Size;

    public required byte[] Creator { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Creator.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetProjectIndexListByCreatorOutput : ISmartContractOutput<GetProjectIndexListByCreatorOutput>
{
    public uint[] IndexListForProjects { get; init; }

    public static GetProjectIndexListByCreatorOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var indexListForProjects = new uint[0];
        for (int i = 0; i < 0; i++)
        {
            indexListForProjects[i] = BinaryPrimitives.ReadUInt32LittleEndian(data[(0 + i * 4)..]);
        }
        return new GetProjectIndexListByCreatorOutput
        {
            IndexListForProjects = indexListForProjects
        };
    }
}

// ═══ Function: getInfoUserInvested (inputType=9) ═══

/// <summary>Input for query.</summary>
public readonly struct GetInfoUserInvestedInput : ISmartContractInput
{
    public const int Size = 32;

    public int SerializedSize => Size;

    public required byte[] InvestorId { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        InvestorId.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetInfoUserInvestedOutput : ISmartContractOutput<GetInfoUserInvestedOutput>
{
    public byte[] ListUserInvested { get; init; }

    public static GetInfoUserInvestedOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetInfoUserInvestedOutput
        {
            ListUserInvested = [] /* unknown struct array investInfo */
        };
    }
}

// ═══ Function: getMaxClaimAmount (inputType=10) ═══

/// <summary>Input for query.</summary>
public readonly struct GetMaxClaimAmountInput : ISmartContractInput
{
    public const int Size = 40;

    public int SerializedSize => Size;

    public required byte[] InvestorId { get; init; }
    public uint IndexOfFundraising { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        InvestorId.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(32), IndexOfFundraising);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetMaxClaimAmountOutput : ISmartContractOutput<GetMaxClaimAmountOutput>
{
    public ulong Amount { get; init; }

    public static GetMaxClaimAmountOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetMaxClaimAmountOutput
        {
            Amount = BinaryPrimitives.ReadUInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: registerInTier (inputType=1) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class RegisterInTierPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 4;

    public ushort InputType => 1;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public uint TierLevel { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), TierLevel);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct RegisterInTierOutput : ISmartContractOutput<RegisterInTierOutput>
{
    public uint TierLevel { get; init; }

    public static RegisterInTierOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new RegisterInTierOutput
        {
            TierLevel = BinaryPrimitives.ReadUInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: logoutFromTier (inputType=2) ═══

/// <summary>Input for procedure (empty payload).</summary>
public sealed class LogoutFromTierPayload : ITransactionPayload, ISmartContractInput
{
    public ushort InputType => 2;
    public ushort InputSize => 0;
    public int SerializedSize => 0;
    public byte[] GetPayloadBytes() => [];
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct LogoutFromTierOutput : ISmartContractOutput<LogoutFromTierOutput>
{
    public bool Result { get; init; }

    public static LogoutFromTierOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new LogoutFromTierOutput
        {
            Result = (data.Slice(0, 1)[0] != 0)
        };
    }
}

// ═══ Procedure: createProject (inputType=3) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class CreateProjectPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 48;

    public ushort InputType => 3;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong TokenName { get; init; }
    public ulong Supply { get; init; }
    public uint StartYear { get; init; }
    public uint StartMonth { get; init; }
    public uint StartDay { get; init; }
    public uint StartHour { get; init; }
    public uint EndYear { get; init; }
    public uint EndMonth { get; init; }
    public uint EndDay { get; init; }
    public uint EndHour { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), TokenName);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(8), Supply);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(16), StartYear);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(20), StartMonth);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(24), StartDay);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(28), StartHour);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(32), EndYear);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(36), EndMonth);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(40), EndDay);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(44), EndHour);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct CreateProjectOutput : ISmartContractOutput<CreateProjectOutput>
{
    public uint IndexOfProject { get; init; }

    public static CreateProjectOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new CreateProjectOutput
        {
            IndexOfProject = BinaryPrimitives.ReadUInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: voteInProject (inputType=4) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class VoteInProjectPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 8;

    public ushort InputType => 4;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public uint IndexOfProject { get; init; }
    public bool Decision { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), IndexOfProject);
        bytes.AsSpan(4, 1)[0] = (byte)(Decision ? 1 : 0);
        return bytes;
    }
}

/// <summary>Output (empty).</summary>
public readonly struct VoteInProjectOutput : ISmartContractOutput<VoteInProjectOutput>
{
    public static VoteInProjectOutput FromBytes(ReadOnlySpan<byte> data) => new();
}

// ═══ Procedure: createFundraising (inputType=5) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class CreateFundraisingPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 176;

    public ushort InputType => 5;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong TokenPrice { get; init; }
    public ulong SoldAmount { get; init; }
    public ulong RequiredFunds { get; init; }
    public uint IndexOfProject { get; init; }
    public uint FirstPhaseStartYear { get; init; }
    public uint FirstPhaseStartMonth { get; init; }
    public uint FirstPhaseStartDay { get; init; }
    public uint FirstPhaseStartHour { get; init; }
    public uint FirstPhaseEndYear { get; init; }
    public uint FirstPhaseEndMonth { get; init; }
    public uint FirstPhaseEndDay { get; init; }
    public uint FirstPhaseEndHour { get; init; }
    public uint SecondPhaseStartYear { get; init; }
    public uint SecondPhaseStartMonth { get; init; }
    public uint SecondPhaseStartDay { get; init; }
    public uint SecondPhaseStartHour { get; init; }
    public uint SecondPhaseEndYear { get; init; }
    public uint SecondPhaseEndMonth { get; init; }
    public uint SecondPhaseEndDay { get; init; }
    public uint SecondPhaseEndHour { get; init; }
    public uint ThirdPhaseStartYear { get; init; }
    public uint ThirdPhaseStartMonth { get; init; }
    public uint ThirdPhaseStartDay { get; init; }
    public uint ThirdPhaseStartHour { get; init; }
    public uint ThirdPhaseEndYear { get; init; }
    public uint ThirdPhaseEndMonth { get; init; }
    public uint ThirdPhaseEndDay { get; init; }
    public uint ThirdPhaseEndHour { get; init; }
    public uint ListingStartYear { get; init; }
    public uint ListingStartMonth { get; init; }
    public uint ListingStartDay { get; init; }
    public uint ListingStartHour { get; init; }
    public uint CliffEndYear { get; init; }
    public uint CliffEndMonth { get; init; }
    public uint CliffEndDay { get; init; }
    public uint CliffEndHour { get; init; }
    public uint VestingEndYear { get; init; }
    public uint VestingEndMonth { get; init; }
    public uint VestingEndDay { get; init; }
    public uint VestingEndHour { get; init; }
    public byte Threshold { get; init; }
    public byte TGE { get; init; }
    public byte StepOfVesting { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), TokenPrice);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(8), SoldAmount);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(16), RequiredFunds);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(24), IndexOfProject);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(28), FirstPhaseStartYear);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(32), FirstPhaseStartMonth);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(36), FirstPhaseStartDay);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(40), FirstPhaseStartHour);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(44), FirstPhaseEndYear);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(48), FirstPhaseEndMonth);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(52), FirstPhaseEndDay);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(56), FirstPhaseEndHour);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(60), SecondPhaseStartYear);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(64), SecondPhaseStartMonth);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(68), SecondPhaseStartDay);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(72), SecondPhaseStartHour);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(76), SecondPhaseEndYear);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(80), SecondPhaseEndMonth);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(84), SecondPhaseEndDay);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(88), SecondPhaseEndHour);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(92), ThirdPhaseStartYear);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(96), ThirdPhaseStartMonth);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(100), ThirdPhaseStartDay);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(104), ThirdPhaseStartHour);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(108), ThirdPhaseEndYear);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(112), ThirdPhaseEndMonth);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(116), ThirdPhaseEndDay);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(120), ThirdPhaseEndHour);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(124), ListingStartYear);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(128), ListingStartMonth);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(132), ListingStartDay);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(136), ListingStartHour);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(140), CliffEndYear);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(144), CliffEndMonth);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(148), CliffEndDay);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(152), CliffEndHour);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(156), VestingEndYear);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(160), VestingEndMonth);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(164), VestingEndDay);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(168), VestingEndHour);
        bytes.AsSpan(172, 1)[0] = Threshold;
        bytes.AsSpan(173, 1)[0] = TGE;
        bytes.AsSpan(174, 1)[0] = StepOfVesting;
        return bytes;
    }
}

/// <summary>Output (empty).</summary>
public readonly struct CreateFundraisingOutput : ISmartContractOutput<CreateFundraisingOutput>
{
    public static CreateFundraisingOutput FromBytes(ReadOnlySpan<byte> data) => new();
}

// ═══ Procedure: investInProject (inputType=6) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class InvestInProjectPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 4;

    public ushort InputType => 6;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public uint IndexOfFundraising { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), IndexOfFundraising);
        return bytes;
    }
}

/// <summary>Output (empty).</summary>
public readonly struct InvestInProjectOutput : ISmartContractOutput<InvestInProjectOutput>
{
    public static InvestInProjectOutput FromBytes(ReadOnlySpan<byte> data) => new();
}

// ═══ Procedure: claimToken (inputType=7) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class ClaimTokenPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 16;

    public ushort InputType => 7;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong Amount { get; init; }
    public uint IndexOfFundraising { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), Amount);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(8), IndexOfFundraising);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct ClaimTokenOutput : ISmartContractOutput<ClaimTokenOutput>
{
    public ulong ClaimedAmount { get; init; }

    public static ClaimTokenOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new ClaimTokenOutput
        {
            ClaimedAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: upgradeTier (inputType=8) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class UpgradeTierPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 4;

    public ushort InputType => 8;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public uint NewTierLevel { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), NewTierLevel);
        return bytes;
    }
}

/// <summary>Output (empty).</summary>
public readonly struct UpgradeTierOutput : ISmartContractOutput<UpgradeTierOutput>
{
    public static UpgradeTierOutput FromBytes(ReadOnlySpan<byte> data) => new();
}

// ═══ Procedure: TransferShareManagementRights (inputType=9) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class TransferShareManagementRightsPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 56;

    public ushort InputType => 9;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required QubicAsset Asset { get; init; }
    public long NumberOfShares { get; init; }
    public uint NewManagingContractIndex { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Asset.WriteTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(40), NumberOfShares);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(48), NewManagingContractIndex);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct TransferShareManagementRightsOutput : ISmartContractOutput<TransferShareManagementRightsOutput>
{
    public long TransferredNumberOfShares { get; init; }

    public static TransferShareManagementRightsOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new TransferShareManagementRightsOutput
        {
            TransferredNumberOfShares = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}
