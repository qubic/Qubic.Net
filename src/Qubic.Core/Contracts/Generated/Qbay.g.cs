// <auto-generated>
// Generated by Qubic.ContractGen from Qbay.h.
// Do not edit manually. Re-run the generator after updating deps/qubic-core.
// </auto-generated>

using System.Buffers.Binary;
using Qubic.Core.Contracts;
using Qubic.Core.Payloads;

namespace Qubic.Core.Contracts.Qbay;

/// <summary>Qbay contract (index 12).</summary>
public static class QbayContract
{
    /// <summary>Contract index on the Qubic network.</summary>
    public const int ContractIndex = 12;

    /// <summary>Gets the 32-byte contract public key.</summary>
    public static byte[] GetPublicKey() => QubicContracts.GetContractPublicKey(ContractIndex);

    /// <summary>Read-only query function IDs.</summary>
    public static class Functions
    {
        /// <summary>getNumberOfNFTForUser (inputType=1).</summary>
        public const uint GetNumberOfNFTForUser = 1;
        /// <summary>getInfoOfNFTUserPossessed (inputType=2).</summary>
        public const uint GetInfoOfNFTUserPossessed = 2;
        /// <summary>getInfoOfMarketplace (inputType=3).</summary>
        public const uint GetInfoOfMarketplace = 3;
        /// <summary>getInfoOfCollectionByCreator (inputType=4).</summary>
        public const uint GetInfoOfCollectionByCreator = 4;
        /// <summary>getInfoOfCollectionById (inputType=5).</summary>
        public const uint GetInfoOfCollectionById = 5;
        /// <summary>getIncomingAuctions (inputType=6).</summary>
        public const uint GetIncomingAuctions = 6;
        /// <summary>getInfoOfNFTById (inputType=7).</summary>
        public const uint GetInfoOfNFTById = 7;
        /// <summary>getUserCreatedCollection (inputType=8).</summary>
        public const uint GetUserCreatedCollection = 8;
        /// <summary>getUserCreatedNFT (inputType=9).</summary>
        public const uint GetUserCreatedNFT = 9;
    }

    /// <summary>State-mutating procedure IDs.</summary>
    public static class Procedures
    {
        /// <summary>settingCFBAndQubicPrice (inputType=1).</summary>
        public const uint SettingCFBAndQubicPrice = 1;
        /// <summary>createCollection (inputType=2).</summary>
        public const uint CreateCollection = 2;
        /// <summary>mint (inputType=3).</summary>
        public const uint Mint = 3;
        /// <summary>mintOfDrop (inputType=4).</summary>
        public const uint MintOfDrop = 4;
        /// <summary>transfer (inputType=5).</summary>
        public const uint Transfer = 5;
        /// <summary>listInMarket (inputType=6).</summary>
        public const uint ListInMarket = 6;
        /// <summary>buy (inputType=7).</summary>
        public const uint Buy = 7;
        /// <summary>cancelSale (inputType=8).</summary>
        public const uint CancelSale = 8;
        /// <summary>listInExchange (inputType=9).</summary>
        public const uint ListInExchange = 9;
        /// <summary>cancelExchange (inputType=10).</summary>
        public const uint CancelExchange = 10;
        /// <summary>makeOffer (inputType=11).</summary>
        public const uint MakeOffer = 11;
        /// <summary>acceptOffer (inputType=12).</summary>
        public const uint AcceptOffer = 12;
        /// <summary>cancelOffer (inputType=13).</summary>
        public const uint CancelOffer = 13;
        /// <summary>createTraditionalAuction (inputType=14).</summary>
        public const uint CreateTraditionalAuction = 14;
        /// <summary>bidOnTraditionalAuction (inputType=15).</summary>
        public const uint BidOnTraditionalAuction = 15;
        /// <summary>TransferShareManagementRights (inputType=16).</summary>
        public const uint TransferShareManagementRights = 16;
        /// <summary>changeStatusOfMarketPlace (inputType=17).</summary>
        public const uint ChangeStatusOfMarketPlace = 17;
    }
}

// ═══ Function: getNumberOfNFTForUser (inputType=1) ═══

/// <summary>Input for query.</summary>
public readonly struct GetNumberOfNFTForUserInput : ISmartContractInput
{
    public const int Size = 32;

    public int SerializedSize => Size;

    public required byte[] User { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        User.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetNumberOfNFTForUserOutput : ISmartContractOutput<GetNumberOfNFTForUserOutput>
{
    public uint NumberOfNFT { get; init; }

    public static GetNumberOfNFTForUserOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetNumberOfNFTForUserOutput
        {
            NumberOfNFT = BinaryPrimitives.ReadUInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Function: getInfoOfNFTUserPossessed (inputType=2) ═══

/// <summary>Input for query.</summary>
public readonly struct GetInfoOfNFTUserPossessedInput : ISmartContractInput
{
    public const int Size = 40;

    public int SerializedSize => Size;

    public required byte[] User { get; init; }
    public uint NFTNumber { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        User.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(32), NFTNumber);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetInfoOfNFTUserPossessedOutput : ISmartContractOutput<GetInfoOfNFTUserPossessedOutput>
{
    public byte[] Creator { get; init; }
    public byte[] Possessor { get; init; }
    public byte[] AskUser { get; init; }
    public byte[] CreatorOfAuction { get; init; }
    public long SalePrice { get; init; }
    public long AskMaxPrice { get; init; }
    public ulong CurrentPriceOfAuction { get; init; }
    public uint Royalty { get; init; }
    public uint NFTidForExchange { get; init; }
    public byte[] URI { get; init; }
    public byte StatusOfAuction { get; init; }
    public byte YearAuctionStarted { get; init; }
    public byte MonthAuctionStarted { get; init; }
    public byte DayAuctionStarted { get; init; }
    public byte HourAuctionStarted { get; init; }
    public byte MinuteAuctionStarted { get; init; }
    public byte SecondAuctionStarted { get; init; }
    public byte YearAuctionEnded { get; init; }
    public byte MonthAuctionEnded { get; init; }
    public byte DayAuctionEnded { get; init; }
    public byte HourAuctionEnded { get; init; }
    public byte MinuteAuctionEnded { get; init; }
    public byte SecondAuctionEnded { get; init; }
    public bool StatusOfSale { get; init; }
    public bool StatusOfAsk { get; init; }
    public bool PaymentMethodOfAsk { get; init; }
    public bool StatusOfExchange { get; init; }
    public bool PaymentMethodOfAuction { get; init; }

    public static GetInfoOfNFTUserPossessedOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var uRI = new byte[64];
        for (int i = 0; i < 64; i++)
        {
            uRI[i] = data.Slice(160 + i * 1, 1)[0];
        }
        return new GetInfoOfNFTUserPossessedOutput
        {
            Creator = data[0..].Slice(0, 32).ToArray(),
            Possessor = data[32..].Slice(0, 32).ToArray(),
            AskUser = data[64..].Slice(0, 32).ToArray(),
            CreatorOfAuction = data[96..].Slice(0, 32).ToArray(),
            SalePrice = BinaryPrimitives.ReadInt64LittleEndian(data[128..]),
            AskMaxPrice = BinaryPrimitives.ReadInt64LittleEndian(data[136..]),
            CurrentPriceOfAuction = BinaryPrimitives.ReadUInt64LittleEndian(data[144..]),
            Royalty = BinaryPrimitives.ReadUInt32LittleEndian(data[152..]),
            NFTidForExchange = BinaryPrimitives.ReadUInt32LittleEndian(data[156..]),
            URI = uRI,
            StatusOfAuction = data.Slice(224, 1)[0],
            YearAuctionStarted = data.Slice(225, 1)[0],
            MonthAuctionStarted = data.Slice(226, 1)[0],
            DayAuctionStarted = data.Slice(227, 1)[0],
            HourAuctionStarted = data.Slice(228, 1)[0],
            MinuteAuctionStarted = data.Slice(229, 1)[0],
            SecondAuctionStarted = data.Slice(230, 1)[0],
            YearAuctionEnded = data.Slice(231, 1)[0],
            MonthAuctionEnded = data.Slice(232, 1)[0],
            DayAuctionEnded = data.Slice(233, 1)[0],
            HourAuctionEnded = data.Slice(234, 1)[0],
            MinuteAuctionEnded = data.Slice(235, 1)[0],
            SecondAuctionEnded = data.Slice(236, 1)[0],
            StatusOfSale = (data.Slice(237, 1)[0] != 0),
            StatusOfAsk = (data.Slice(238, 1)[0] != 0),
            PaymentMethodOfAsk = (data.Slice(239, 1)[0] != 0),
            StatusOfExchange = (data.Slice(240, 1)[0] != 0),
            PaymentMethodOfAuction = (data.Slice(241, 1)[0] != 0)
        };
    }
}

// ═══ Function: getInfoOfMarketplace (inputType=3) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetInfoOfMarketplaceInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetInfoOfMarketplaceOutput : ISmartContractOutput<GetInfoOfMarketplaceOutput>
{
    public ulong PriceOfCFB { get; init; }
    public ulong PriceOfQubic { get; init; }
    public ulong NumberOfNFTIncoming { get; init; }
    public ulong EarnedQubic { get; init; }
    public ulong EarnedCFB { get; init; }
    public uint NumberOfCollection { get; init; }
    public uint NumberOfNFT { get; init; }
    public bool StatusOfMarketPlace { get; init; }

    public static GetInfoOfMarketplaceOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetInfoOfMarketplaceOutput
        {
            PriceOfCFB = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            PriceOfQubic = BinaryPrimitives.ReadUInt64LittleEndian(data[8..]),
            NumberOfNFTIncoming = BinaryPrimitives.ReadUInt64LittleEndian(data[16..]),
            EarnedQubic = BinaryPrimitives.ReadUInt64LittleEndian(data[24..]),
            EarnedCFB = BinaryPrimitives.ReadUInt64LittleEndian(data[32..]),
            NumberOfCollection = BinaryPrimitives.ReadUInt32LittleEndian(data[40..]),
            NumberOfNFT = BinaryPrimitives.ReadUInt32LittleEndian(data[44..]),
            StatusOfMarketPlace = (data.Slice(48, 1)[0] != 0)
        };
    }
}

// ═══ Function: getInfoOfCollectionByCreator (inputType=4) ═══

/// <summary>Input for query.</summary>
public readonly struct GetInfoOfCollectionByCreatorInput : ISmartContractInput
{
    public const int Size = 40;

    public int SerializedSize => Size;

    public required byte[] Creator { get; init; }
    public uint OrderOfCollection { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Creator.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(32), OrderOfCollection);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetInfoOfCollectionByCreatorOutput : ISmartContractOutput<GetInfoOfCollectionByCreatorOutput>
{
    public ulong PriceForDropMint { get; init; }
    public uint IdOfCollection { get; init; }
    public uint Royalty { get; init; }
    public int CurrentSize { get; init; }
    public uint MaxSizeHoldingPerOneId { get; init; }
    public byte[] URI { get; init; }
    public bool TypeOfCollection { get; init; }

    public static GetInfoOfCollectionByCreatorOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var uRI = new byte[64];
        for (int i = 0; i < 64; i++)
        {
            uRI[i] = data.Slice(24 + i * 1, 1)[0];
        }
        return new GetInfoOfCollectionByCreatorOutput
        {
            PriceForDropMint = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            IdOfCollection = BinaryPrimitives.ReadUInt32LittleEndian(data[8..]),
            Royalty = BinaryPrimitives.ReadUInt32LittleEndian(data[12..]),
            CurrentSize = BinaryPrimitives.ReadInt32LittleEndian(data[16..]),
            MaxSizeHoldingPerOneId = BinaryPrimitives.ReadUInt32LittleEndian(data[20..]),
            URI = uRI,
            TypeOfCollection = (data.Slice(88, 1)[0] != 0)
        };
    }
}

// ═══ Function: getInfoOfCollectionById (inputType=5) ═══

/// <summary>Input for query.</summary>
public readonly struct GetInfoOfCollectionByIdInput : ISmartContractInput
{
    public const int Size = 4;

    public int SerializedSize => Size;

    public uint IdOfCollection { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), IdOfCollection);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetInfoOfCollectionByIdOutput : ISmartContractOutput<GetInfoOfCollectionByIdOutput>
{
    public byte[] Creator { get; init; }
    public ulong PriceForDropMint { get; init; }
    public uint Royalty { get; init; }
    public int CurrentSize { get; init; }
    public uint MaxSizeHoldingPerOneId { get; init; }
    public byte[] URI { get; init; }
    public bool TypeOfCollection { get; init; }

    public static GetInfoOfCollectionByIdOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var uRI = new byte[64];
        for (int i = 0; i < 64; i++)
        {
            uRI[i] = data.Slice(52 + i * 1, 1)[0];
        }
        return new GetInfoOfCollectionByIdOutput
        {
            Creator = data[0..].Slice(0, 32).ToArray(),
            PriceForDropMint = BinaryPrimitives.ReadUInt64LittleEndian(data[32..]),
            Royalty = BinaryPrimitives.ReadUInt32LittleEndian(data[40..]),
            CurrentSize = BinaryPrimitives.ReadInt32LittleEndian(data[44..]),
            MaxSizeHoldingPerOneId = BinaryPrimitives.ReadUInt32LittleEndian(data[48..]),
            URI = uRI,
            TypeOfCollection = (data.Slice(116, 1)[0] != 0)
        };
    }
}

// ═══ Function: getIncomingAuctions (inputType=6) ═══

/// <summary>Input for query.</summary>
public readonly struct GetIncomingAuctionsInput : ISmartContractInput
{
    public const int Size = 8;

    public int SerializedSize => Size;

    public uint Offset { get; init; }
    public uint Count { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), Offset);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(4), Count);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetIncomingAuctionsOutput : ISmartContractOutput<GetIncomingAuctionsOutput>
{
    public uint[] NFTId { get; init; }

    public static GetIncomingAuctionsOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var nFTId = new uint[1024];
        for (int i = 0; i < 1024; i++)
        {
            nFTId[i] = BinaryPrimitives.ReadUInt32LittleEndian(data[(0 + i * 4)..]);
        }
        return new GetIncomingAuctionsOutput
        {
            NFTId = nFTId
        };
    }
}

// ═══ Function: getInfoOfNFTById (inputType=7) ═══

/// <summary>Input for query.</summary>
public readonly struct GetInfoOfNFTByIdInput : ISmartContractInput
{
    public const int Size = 4;

    public int SerializedSize => Size;

    public uint NFTId { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), NFTId);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetInfoOfNFTByIdOutput : ISmartContractOutput<GetInfoOfNFTByIdOutput>
{
    public byte[] Creator { get; init; }
    public byte[] Possessor { get; init; }
    public byte[] AskUser { get; init; }
    public byte[] CreatorOfAuction { get; init; }
    public long SalePrice { get; init; }
    public long AskMaxPrice { get; init; }
    public ulong CurrentPriceOfAuction { get; init; }
    public uint Royalty { get; init; }
    public uint NFTidForExchange { get; init; }
    public byte[] URI { get; init; }
    public byte StatusOfAuction { get; init; }
    public byte YearAuctionStarted { get; init; }
    public byte MonthAuctionStarted { get; init; }
    public byte DayAuctionStarted { get; init; }
    public byte HourAuctionStarted { get; init; }
    public byte MinuteAuctionStarted { get; init; }
    public byte SecondAuctionStarted { get; init; }
    public byte YearAuctionEnded { get; init; }
    public byte MonthAuctionEnded { get; init; }
    public byte DayAuctionEnded { get; init; }
    public byte HourAuctionEnded { get; init; }
    public byte MinuteAuctionEnded { get; init; }
    public byte SecondAuctionEnded { get; init; }
    public bool StatusOfSale { get; init; }
    public bool StatusOfAsk { get; init; }
    public bool PaymentMethodOfAsk { get; init; }
    public bool StatusOfExchange { get; init; }
    public bool PaymentMethodOfAuction { get; init; }

    public static GetInfoOfNFTByIdOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var uRI = new byte[64];
        for (int i = 0; i < 64; i++)
        {
            uRI[i] = data.Slice(160 + i * 1, 1)[0];
        }
        return new GetInfoOfNFTByIdOutput
        {
            Creator = data[0..].Slice(0, 32).ToArray(),
            Possessor = data[32..].Slice(0, 32).ToArray(),
            AskUser = data[64..].Slice(0, 32).ToArray(),
            CreatorOfAuction = data[96..].Slice(0, 32).ToArray(),
            SalePrice = BinaryPrimitives.ReadInt64LittleEndian(data[128..]),
            AskMaxPrice = BinaryPrimitives.ReadInt64LittleEndian(data[136..]),
            CurrentPriceOfAuction = BinaryPrimitives.ReadUInt64LittleEndian(data[144..]),
            Royalty = BinaryPrimitives.ReadUInt32LittleEndian(data[152..]),
            NFTidForExchange = BinaryPrimitives.ReadUInt32LittleEndian(data[156..]),
            URI = uRI,
            StatusOfAuction = data.Slice(224, 1)[0],
            YearAuctionStarted = data.Slice(225, 1)[0],
            MonthAuctionStarted = data.Slice(226, 1)[0],
            DayAuctionStarted = data.Slice(227, 1)[0],
            HourAuctionStarted = data.Slice(228, 1)[0],
            MinuteAuctionStarted = data.Slice(229, 1)[0],
            SecondAuctionStarted = data.Slice(230, 1)[0],
            YearAuctionEnded = data.Slice(231, 1)[0],
            MonthAuctionEnded = data.Slice(232, 1)[0],
            DayAuctionEnded = data.Slice(233, 1)[0],
            HourAuctionEnded = data.Slice(234, 1)[0],
            MinuteAuctionEnded = data.Slice(235, 1)[0],
            SecondAuctionEnded = data.Slice(236, 1)[0],
            StatusOfSale = (data.Slice(237, 1)[0] != 0),
            StatusOfAsk = (data.Slice(238, 1)[0] != 0),
            PaymentMethodOfAsk = (data.Slice(239, 1)[0] != 0),
            StatusOfExchange = (data.Slice(240, 1)[0] != 0),
            PaymentMethodOfAuction = (data.Slice(241, 1)[0] != 0)
        };
    }
}

// ═══ Function: getUserCreatedCollection (inputType=8) ═══

/// <summary>Input for query.</summary>
public readonly struct GetUserCreatedCollectionInput : ISmartContractInput
{
    public const int Size = 40;

    public int SerializedSize => Size;

    public required byte[] User { get; init; }
    public uint Offset { get; init; }
    public uint Count { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        User.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(32), Offset);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(36), Count);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetUserCreatedCollectionOutput : ISmartContractOutput<GetUserCreatedCollectionOutput>
{
    public uint[] CollectionId { get; init; }

    public static GetUserCreatedCollectionOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var collectionId = new uint[1024];
        for (int i = 0; i < 1024; i++)
        {
            collectionId[i] = BinaryPrimitives.ReadUInt32LittleEndian(data[(0 + i * 4)..]);
        }
        return new GetUserCreatedCollectionOutput
        {
            CollectionId = collectionId
        };
    }
}

// ═══ Function: getUserCreatedNFT (inputType=9) ═══

/// <summary>Input for query.</summary>
public readonly struct GetUserCreatedNFTInput : ISmartContractInput
{
    public const int Size = 40;

    public int SerializedSize => Size;

    public required byte[] User { get; init; }
    public uint Offset { get; init; }
    public uint Count { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        User.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(32), Offset);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(36), Count);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetUserCreatedNFTOutput : ISmartContractOutput<GetUserCreatedNFTOutput>
{
    public uint[] NFTId { get; init; }

    public static GetUserCreatedNFTOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var nFTId = new uint[1024];
        for (int i = 0; i < 1024; i++)
        {
            nFTId[i] = BinaryPrimitives.ReadUInt32LittleEndian(data[(0 + i * 4)..]);
        }
        return new GetUserCreatedNFTOutput
        {
            NFTId = nFTId
        };
    }
}

// ═══ Procedure: settingCFBAndQubicPrice (inputType=1) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class SettingCFBAndQubicPricePayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 16;

    public ushort InputType => 1;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong CFBPrice { get; init; }
    public ulong QubicPrice { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), CFBPrice);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(8), QubicPrice);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct SettingCFBAndQubicPriceOutput : ISmartContractOutput<SettingCFBAndQubicPriceOutput>
{
    public uint ReturnCode { get; init; }

    public static SettingCFBAndQubicPriceOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new SettingCFBAndQubicPriceOutput
        {
            ReturnCode = BinaryPrimitives.ReadUInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: createCollection (inputType=2) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class CreateCollectionPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 88;

    public ushort InputType => 2;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong PriceForDropMint { get; init; }
    public uint Volume { get; init; }
    public uint Royalty { get; init; }
    public uint MaxSizePerOneId { get; init; }
    public byte[] URI { get; init; }
    public bool TypeOfCollection { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), PriceForDropMint);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(8), Volume);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(12), Royalty);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(16), MaxSizePerOneId);
        for (int i = 0; i < 64 && URI != null && i < URI.Length; i++)
        {
            bytes.AsSpan(20 + i * 1)[0] = URI[i];
        }
        bytes.AsSpan(84, 1)[0] = (byte)(TypeOfCollection ? 1 : 0);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct CreateCollectionOutput : ISmartContractOutput<CreateCollectionOutput>
{
    public uint ReturnCode { get; init; }

    public static CreateCollectionOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new CreateCollectionOutput
        {
            ReturnCode = BinaryPrimitives.ReadUInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: mint (inputType=3) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class MintPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 76;

    public ushort InputType => 3;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public uint Royalty { get; init; }
    public uint CollectionId { get; init; }
    public byte[] URI { get; init; }
    public bool TypeOfMint { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), Royalty);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(4), CollectionId);
        for (int i = 0; i < 64 && URI != null && i < URI.Length; i++)
        {
            bytes.AsSpan(8 + i * 1)[0] = URI[i];
        }
        bytes.AsSpan(72, 1)[0] = (byte)(TypeOfMint ? 1 : 0);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct MintOutput : ISmartContractOutput<MintOutput>
{
    public uint ReturnCode { get; init; }

    public static MintOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new MintOutput
        {
            ReturnCode = BinaryPrimitives.ReadUInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: mintOfDrop (inputType=4) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class MintOfDropPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 68;

    public ushort InputType => 4;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public uint CollectionId { get; init; }
    public byte[] URI { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), CollectionId);
        for (int i = 0; i < 64 && URI != null && i < URI.Length; i++)
        {
            bytes.AsSpan(4 + i * 1)[0] = URI[i];
        }
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct MintOfDropOutput : ISmartContractOutput<MintOfDropOutput>
{
    public uint ReturnCode { get; init; }

    public static MintOfDropOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new MintOfDropOutput
        {
            ReturnCode = BinaryPrimitives.ReadUInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: transfer (inputType=5) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class TransferPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 40;

    public ushort InputType => 5;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] Receiver { get; init; }
    public uint NFTid { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Receiver.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(32), NFTid);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct TransferOutput : ISmartContractOutput<TransferOutput>
{
    public uint ReturnCode { get; init; }

    public static TransferOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new TransferOutput
        {
            ReturnCode = BinaryPrimitives.ReadUInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: listInMarket (inputType=6) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class ListInMarketPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 16;

    public ushort InputType => 6;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong Price { get; init; }
    public uint NFTid { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), Price);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(8), NFTid);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct ListInMarketOutput : ISmartContractOutput<ListInMarketOutput>
{
    public uint ReturnCode { get; init; }

    public static ListInMarketOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new ListInMarketOutput
        {
            ReturnCode = BinaryPrimitives.ReadUInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: buy (inputType=7) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class BuyPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 8;

    public ushort InputType => 7;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public uint NFTid { get; init; }
    public bool MethodOfPayment { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), NFTid);
        bytes.AsSpan(4, 1)[0] = (byte)(MethodOfPayment ? 1 : 0);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct BuyOutput : ISmartContractOutput<BuyOutput>
{
    public uint ReturnCode { get; init; }

    public static BuyOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new BuyOutput
        {
            ReturnCode = BinaryPrimitives.ReadUInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: cancelSale (inputType=8) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class CancelSalePayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 4;

    public ushort InputType => 8;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public uint NFTid { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), NFTid);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct CancelSaleOutput : ISmartContractOutput<CancelSaleOutput>
{
    public uint ReturnCode { get; init; }

    public static CancelSaleOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new CancelSaleOutput
        {
            ReturnCode = BinaryPrimitives.ReadUInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: listInExchange (inputType=9) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class ListInExchangePayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 8;

    public ushort InputType => 9;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public uint PossessedNFT { get; init; }
    public uint AnotherNFT { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), PossessedNFT);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(4), AnotherNFT);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct ListInExchangeOutput : ISmartContractOutput<ListInExchangeOutput>
{
    public uint ReturnCode { get; init; }

    public static ListInExchangeOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new ListInExchangeOutput
        {
            ReturnCode = BinaryPrimitives.ReadUInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: cancelExchange (inputType=10) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class CancelExchangePayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 8;

    public ushort InputType => 10;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public uint PossessedNFT { get; init; }
    public uint AnotherNFT { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), PossessedNFT);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(4), AnotherNFT);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct CancelExchangeOutput : ISmartContractOutput<CancelExchangeOutput>
{
    public uint ReturnCode { get; init; }

    public static CancelExchangeOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new CancelExchangeOutput
        {
            ReturnCode = BinaryPrimitives.ReadUInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: makeOffer (inputType=11) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class MakeOfferPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 16;

    public ushort InputType => 11;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong AskPrice { get; init; }
    public uint NFTid { get; init; }
    public bool PaymentMethod { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), AskPrice);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(8), NFTid);
        bytes.AsSpan(12, 1)[0] = (byte)(PaymentMethod ? 1 : 0);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct MakeOfferOutput : ISmartContractOutput<MakeOfferOutput>
{
    public uint ReturnCode { get; init; }

    public static MakeOfferOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new MakeOfferOutput
        {
            ReturnCode = BinaryPrimitives.ReadUInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: acceptOffer (inputType=12) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class AcceptOfferPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 4;

    public ushort InputType => 12;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public uint NFTid { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), NFTid);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct AcceptOfferOutput : ISmartContractOutput<AcceptOfferOutput>
{
    public uint ReturnCode { get; init; }

    public static AcceptOfferOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new AcceptOfferOutput
        {
            ReturnCode = BinaryPrimitives.ReadUInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: cancelOffer (inputType=13) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class CancelOfferPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 4;

    public ushort InputType => 13;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public uint NFTid { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), NFTid);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct CancelOfferOutput : ISmartContractOutput<CancelOfferOutput>
{
    public uint ReturnCode { get; init; }

    public static CancelOfferOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new CancelOfferOutput
        {
            ReturnCode = BinaryPrimitives.ReadUInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: createTraditionalAuction (inputType=14) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class CreateTraditionalAuctionPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 48;

    public ushort InputType => 14;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong MinPrice { get; init; }
    public uint NFTId { get; init; }
    public uint StartYear { get; init; }
    public uint StartMonth { get; init; }
    public uint StartDay { get; init; }
    public uint StartHour { get; init; }
    public uint EndYear { get; init; }
    public uint EndMonth { get; init; }
    public uint EndDay { get; init; }
    public uint EndHour { get; init; }
    public bool PaymentMethodOfAuction { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), MinPrice);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(8), NFTId);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(12), StartYear);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(16), StartMonth);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(20), StartDay);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(24), StartHour);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(28), EndYear);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(32), EndMonth);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(36), EndDay);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(40), EndHour);
        bytes.AsSpan(44, 1)[0] = (byte)(PaymentMethodOfAuction ? 1 : 0);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct CreateTraditionalAuctionOutput : ISmartContractOutput<CreateTraditionalAuctionOutput>
{
    public uint ReturnCode { get; init; }

    public static CreateTraditionalAuctionOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new CreateTraditionalAuctionOutput
        {
            ReturnCode = BinaryPrimitives.ReadUInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: bidOnTraditionalAuction (inputType=15) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class BidOnTraditionalAuctionPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 16;

    public ushort InputType => 15;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong Price { get; init; }
    public uint NFTId { get; init; }
    public bool PaymentMethod { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), Price);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(8), NFTId);
        bytes.AsSpan(12, 1)[0] = (byte)(PaymentMethod ? 1 : 0);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct BidOnTraditionalAuctionOutput : ISmartContractOutput<BidOnTraditionalAuctionOutput>
{
    public uint ReturnCode { get; init; }

    public static BidOnTraditionalAuctionOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new BidOnTraditionalAuctionOutput
        {
            ReturnCode = BinaryPrimitives.ReadUInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: TransferShareManagementRights (inputType=16) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class TransferShareManagementRightsPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 56;

    public ushort InputType => 16;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required QubicAsset Asset { get; init; }
    public long NumberOfShares { get; init; }
    public uint NewManagingContractIndex { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Asset.WriteTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(40), NumberOfShares);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(48), NewManagingContractIndex);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct TransferShareManagementRightsOutput : ISmartContractOutput<TransferShareManagementRightsOutput>
{
    public long TransferredNumberOfShares { get; init; }
    public uint ReturnCode { get; init; }

    public static TransferShareManagementRightsOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new TransferShareManagementRightsOutput
        {
            TransferredNumberOfShares = BinaryPrimitives.ReadInt64LittleEndian(data[0..]),
            ReturnCode = BinaryPrimitives.ReadUInt32LittleEndian(data[8..])
        };
    }
}

// ═══ Procedure: changeStatusOfMarketPlace (inputType=17) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class ChangeStatusOfMarketPlacePayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 1;

    public ushort InputType => 17;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public bool Status { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        bytes.AsSpan(0, 1)[0] = (byte)(Status ? 1 : 0);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct ChangeStatusOfMarketPlaceOutput : ISmartContractOutput<ChangeStatusOfMarketPlaceOutput>
{
    public uint ReturnCode { get; init; }

    public static ChangeStatusOfMarketPlaceOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new ChangeStatusOfMarketPlaceOutput
        {
            ReturnCode = BinaryPrimitives.ReadUInt32LittleEndian(data[0..])
        };
    }
}
