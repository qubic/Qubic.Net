// <auto-generated>
// Generated by Qubic.ContractGen from ComputorControlledFund.h.
// Do not edit manually. Re-run the generator after updating deps/qubic-core.
// </auto-generated>

using System.Buffers.Binary;
using Qubic.Core.Contracts;
using Qubic.Core.Payloads;

namespace Qubic.Core.Contracts.Ccf;

/// <summary>Ccf contract (index 8).</summary>
public static class CcfContract
{
    /// <summary>Contract index on the Qubic network.</summary>
    public const int ContractIndex = 8;

    /// <summary>Gets the 32-byte contract public key.</summary>
    public static byte[] GetPublicKey() => QubicContracts.GetContractPublicKey(ContractIndex);

    /// <summary>Read-only query function IDs.</summary>
    public static class Functions
    {
        /// <summary>GetProposalIndices (inputType=1).</summary>
        public const uint GetProposalIndices = 1;
        /// <summary>GetProposal (inputType=2).</summary>
        public const uint GetProposal = 2;
        /// <summary>GetVote (inputType=3).</summary>
        public const uint GetVote = 3;
        /// <summary>GetVotingResults (inputType=4).</summary>
        public const uint GetVotingResults = 4;
        /// <summary>GetLatestTransfers (inputType=5).</summary>
        public const uint GetLatestTransfers = 5;
        /// <summary>GetProposalFee (inputType=6).</summary>
        public const uint GetProposalFee = 6;
        /// <summary>GetRegularPayments (inputType=7).</summary>
        public const uint GetRegularPayments = 7;
    }

    /// <summary>State-mutating procedure IDs.</summary>
    public static class Procedures
    {
        /// <summary>SetProposal (inputType=1).</summary>
        public const uint SetProposal = 1;
        /// <summary>Vote (inputType=2).</summary>
        public const uint Vote = 2;
    }
}

// ═══ Function: GetProposalIndices (inputType=1) ═══

/// <summary>Input for query.</summary>
public readonly struct GetProposalIndicesInput : ISmartContractInput
{
    public const int Size = 8;

    public int SerializedSize => Size;

    public bool ActiveProposals { get; init; }
    public int PrevProposalIndex { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        bytes.AsSpan(0, 1)[0] = (byte)(ActiveProposals ? 1 : 0);
        BinaryPrimitives.WriteInt32LittleEndian(bytes.AsSpan(4), PrevProposalIndex);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetProposalIndicesOutput : ISmartContractOutput<GetProposalIndicesOutput>
{
    public ushort NumOfIndices { get; init; }
    public ushort[] Indices { get; init; }

    public static GetProposalIndicesOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var indices = new ushort[64];
        for (int i = 0; i < 64; i++)
        {
            indices[i] = BinaryPrimitives.ReadUInt16LittleEndian(data[(2 + i * 2)..]);
        }
        return new GetProposalIndicesOutput
        {
            NumOfIndices = BinaryPrimitives.ReadUInt16LittleEndian(data[0..]),
            Indices = indices
        };
    }
}

// ═══ Function: GetProposal (inputType=2) ═══

/// <summary>Input for query.</summary>
public readonly struct GetProposalInput : ISmartContractInput
{
    public const int Size = 40;

    public int SerializedSize => Size;

    public required byte[] SubscriptionDestination { get; init; }
    public ushort ProposalIndex { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        SubscriptionDestination.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt16LittleEndian(bytes.AsSpan(32), ProposalIndex);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetProposalOutput : ISmartContractOutput<GetProposalOutput>
{
    public bool Okay { get; init; }
    public bool HasSubscriptionProposal { get; init; }
    public bool HasActiveSubscription { get; init; }
    public byte[] _padding0 { get; init; }
    public byte[] _padding1 { get; init; }
    public byte[] ProposerPublicKey { get; init; }
    public byte[] Proposal { get; init; }
    public byte[] Subscription { get; init; }
    public byte[] SubscriptionProposal { get; init; }

    public static GetProposalOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var _padding0 = new byte[1];
        for (int i = 0; i < 1; i++)
        {
            _padding0[i] = data.Slice(3 + i * 1, 1)[0];
        }
        var _padding1 = new byte[4];
        for (int i = 0; i < 4; i++)
        {
            _padding1[i] = data.Slice(4 + i * 1, 1)[0];
        }
        return new GetProposalOutput
        {
            Okay = (data.Slice(0, 1)[0] != 0),
            HasSubscriptionProposal = (data.Slice(1, 1)[0] != 0),
            HasActiveSubscription = (data.Slice(2, 1)[0] != 0),
            _padding0 = _padding0,
            _padding1 = _padding1,
            ProposerPublicKey = data[8..].Slice(0, 32).ToArray(),
            Proposal = [] /* unknown type ProposalDataT */,
            Subscription = [] /* unknown type SubscriptionData */,
            SubscriptionProposal = [] /* unknown type SubscriptionProposalData */
        };
    }
}

// ═══ Function: GetVote (inputType=3) ═══

/// <summary>Input for query.</summary>
public readonly struct GetVoteInput : ISmartContractInput
{
    public const int Size = 40;

    public int SerializedSize => Size;

    public required byte[] Voter { get; init; }
    public ushort ProposalIndex { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Voter.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt16LittleEndian(bytes.AsSpan(32), ProposalIndex);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetVoteOutput : ISmartContractOutput<GetVoteOutput>
{
    public bool Okay { get; init; }
    public byte[] Vote { get; init; }

    public static GetVoteOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetVoteOutput
        {
            Okay = (data.Slice(0, 1)[0] != 0),
            Vote = [] /* unknown type ProposalSingleVoteDataV1 */
        };
    }
}

// ═══ Function: GetVotingResults (inputType=4) ═══

/// <summary>Input for query.</summary>
public readonly struct GetVotingResultsInput : ISmartContractInput
{
    public const int Size = 2;

    public int SerializedSize => Size;

    public ushort ProposalIndex { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt16LittleEndian(bytes.AsSpan(0), ProposalIndex);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetVotingResultsOutput : ISmartContractOutput<GetVotingResultsOutput>
{
    public bool Okay { get; init; }
    public byte[] Results { get; init; }

    public static GetVotingResultsOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetVotingResultsOutput
        {
            Okay = (data.Slice(0, 1)[0] != 0),
            Results = [] /* unknown type ProposalSummarizedVotingDataV1 */
        };
    }
}

// ═══ Function: GetLatestTransfers (inputType=5) ═══

/// <summary>Nested type from GetLatestTransfers.</summary>
public readonly struct GetLatestTransfersLatestTransfersEntry
{
    public const int Size = 304;

    public required byte[] Destination { get; init; }
    public byte[] Url { get; init; }
    public long Amount { get; init; }
    public uint Tick { get; init; }
    public bool Success { get; init; }

    public static GetLatestTransfersLatestTransfersEntry ReadFrom(ReadOnlySpan<byte> data)
    {
        var url = new byte[256];
        for (int i = 0; i < 256; i++)
        {
            url[i] = data.Slice(32 + i * 1, 1)[0];
        }
        return new GetLatestTransfersLatestTransfersEntry
        {
            Destination = data[0..].Slice(0, 32).ToArray(),
            Url = url,
            Amount = BinaryPrimitives.ReadInt64LittleEndian(data[288..]),
            Tick = BinaryPrimitives.ReadUInt32LittleEndian(data[296..]),
            Success = (data.Slice(300, 1)[0] != 0)
        };
    }
}

/// <summary>Input for query (empty).</summary>
public readonly struct GetLatestTransfersInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetLatestTransfersOutput : ISmartContractOutput<GetLatestTransfersOutput>
{
    public GetLatestTransfersLatestTransfersEntry[] Entries { get; init; }

    public static GetLatestTransfersOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var entries = new GetLatestTransfersLatestTransfersEntry[128];
        for (int i = 0; i < 128; i++)
        {
            entries[i] = GetLatestTransfersLatestTransfersEntry.ReadFrom(data.Slice(0 + i * GetLatestTransfersLatestTransfersEntry.Size, GetLatestTransfersLatestTransfersEntry.Size));
        }
        return new GetLatestTransfersOutput
        {
            Entries = entries
        };
    }
}

// ═══ Function: GetProposalFee (inputType=6) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetProposalFeeInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetProposalFeeOutput : ISmartContractOutput<GetProposalFeeOutput>
{
    public uint ProposalFee { get; init; }

    public static GetProposalFeeOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetProposalFeeOutput
        {
            ProposalFee = BinaryPrimitives.ReadUInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Function: GetRegularPayments (inputType=7) ═══

/// <summary>Nested type from GetRegularPayments.</summary>
public readonly struct GetRegularPaymentsRegularPaymentEntry
{
    public const int Size = 312;

    public required byte[] Destination { get; init; }
    public byte[] Url { get; init; }
    public long Amount { get; init; }
    public uint Tick { get; init; }
    public int PeriodIndex { get; init; }
    public bool Success { get; init; }
    public byte[] _padding0 { get; init; }
    public byte[] _padding1 { get; init; }

    public static GetRegularPaymentsRegularPaymentEntry ReadFrom(ReadOnlySpan<byte> data)
    {
        var url = new byte[256];
        for (int i = 0; i < 256; i++)
        {
            url[i] = data.Slice(32 + i * 1, 1)[0];
        }
        var _padding0 = new byte[1];
        for (int i = 0; i < 1; i++)
        {
            _padding0[i] = data.Slice(305 + i * 1, 1)[0];
        }
        var _padding1 = new byte[2];
        for (int i = 0; i < 2; i++)
        {
            _padding1[i] = data.Slice(306 + i * 1, 1)[0];
        }
        return new GetRegularPaymentsRegularPaymentEntry
        {
            Destination = data[0..].Slice(0, 32).ToArray(),
            Url = url,
            Amount = BinaryPrimitives.ReadInt64LittleEndian(data[288..]),
            Tick = BinaryPrimitives.ReadUInt32LittleEndian(data[296..]),
            PeriodIndex = BinaryPrimitives.ReadInt32LittleEndian(data[300..]),
            Success = (data.Slice(304, 1)[0] != 0),
            _padding0 = _padding0,
            _padding1 = _padding1
        };
    }
}

/// <summary>Input for query (empty).</summary>
public readonly struct GetRegularPaymentsInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetRegularPaymentsOutput : ISmartContractOutput<GetRegularPaymentsOutput>
{
    public GetRegularPaymentsRegularPaymentEntry[] Entries { get; init; }

    public static GetRegularPaymentsOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var entries = new GetRegularPaymentsRegularPaymentEntry[128];
        for (int i = 0; i < 128; i++)
        {
            entries[i] = GetRegularPaymentsRegularPaymentEntry.ReadFrom(data.Slice(0 + i * GetRegularPaymentsRegularPaymentEntry.Size, GetRegularPaymentsRegularPaymentEntry.Size));
        }
        return new GetRegularPaymentsOutput
        {
            Entries = entries
        };
    }
}

// ═══ Procedure: SetProposal (inputType=1) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class SetProposalPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 24;

    public ushort InputType => 1;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public byte[] Proposal { get; init; }
    public bool IsSubscription { get; init; }
    public byte WeeksPerPeriod { get; init; }
    public byte[] _padding0 { get; init; }
    public uint StartEpoch { get; init; }
    public ulong AmountPerPeriod { get; init; }
    public uint NumberOfPeriods { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        // TODO: serialize unknown type ProposalDataT for Proposal
        bytes.AsSpan(0, 1)[0] = (byte)(IsSubscription ? 1 : 0);
        bytes.AsSpan(1, 1)[0] = WeeksPerPeriod;
        for (int i = 0; i < 2 && _padding0 != null && i < _padding0.Length; i++)
        {
            bytes.AsSpan(2 + i * 1)[0] = _padding0[i];
        }
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(4), StartEpoch);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(8), AmountPerPeriod);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(16), NumberOfPeriods);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct SetProposalOutput : ISmartContractOutput<SetProposalOutput>
{
    public ushort ProposalIndex { get; init; }

    public static SetProposalOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new SetProposalOutput
        {
            ProposalIndex = BinaryPrimitives.ReadUInt16LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: Vote (inputType=2) ═══

/// <summary>Input for procedure (empty payload).</summary>
public sealed class VotePayload : ITransactionPayload, ISmartContractInput
{
    public ushort InputType => 2;
    public ushort InputSize => 0;
    public int SerializedSize => 0;
    public byte[] GetPayloadBytes() => [];
    public byte[] ToBytes() => [];
}

/// <summary>Output (empty).</summary>
public readonly struct VoteOutput : ISmartContractOutput<VoteOutput>
{
    public static VoteOutput FromBytes(ReadOnlySpan<byte> data) => new();
}
