// <auto-generated>
// Generated by Qubic.ContractGen from QDuel.h.
// Do not edit manually. Re-run the generator after updating deps/qubic-core.
// </auto-generated>

using System.Buffers.Binary;
using Qubic.Core.Contracts;
using Qubic.Core.Payloads;

namespace Qubic.Core.Contracts.Qduel;

/// <summary>Qduel contract (index 23).</summary>
public static class QduelContract
{
    /// <summary>Contract index on the Qubic network.</summary>
    public const int ContractIndex = 23;

    /// <summary>Gets the 32-byte contract public key.</summary>
    public static byte[] GetPublicKey() => QubicContracts.GetContractPublicKey(ContractIndex);

    /// <summary>Read-only query function IDs.</summary>
    public static class Functions
    {
        /// <summary>GetPercentFees (inputType=1).</summary>
        public const uint GetPercentFees = 1;
        /// <summary>GetRooms (inputType=2).</summary>
        public const uint GetRooms = 2;
        /// <summary>GetTTLHours (inputType=3).</summary>
        public const uint GetTTLHours = 3;
        /// <summary>GetUserProfile (inputType=4).</summary>
        public const uint GetUserProfile = 4;
    }

    /// <summary>State-mutating procedure IDs.</summary>
    public static class Procedures
    {
        /// <summary>CreateRoom (inputType=1).</summary>
        public const uint CreateRoom = 1;
        /// <summary>ConnectToRoom (inputType=2).</summary>
        public const uint ConnectToRoom = 2;
        /// <summary>SetPercentFees (inputType=3).</summary>
        public const uint SetPercentFees = 3;
        /// <summary>SetTTLHours (inputType=4).</summary>
        public const uint SetTTLHours = 4;
        /// <summary>Deposit (inputType=5).</summary>
        public const uint Deposit = 5;
        /// <summary>Withdraw (inputType=6).</summary>
        public const uint Withdraw = 6;
    }
}

// ═══ Function: GetPercentFees (inputType=1) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetPercentFeesInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetPercentFeesOutput : ISmartContractOutput<GetPercentFeesOutput>
{
    public byte DevFeePercentBps { get; init; }
    public byte BurnFeePercentBps { get; init; }
    public byte ShareholdersFeePercentBps { get; init; }
    public ushort PercentScale { get; init; }
    public ulong ReturnCode { get; init; }

    public static GetPercentFeesOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetPercentFeesOutput
        {
            DevFeePercentBps = data.Slice(0, 1)[0],
            BurnFeePercentBps = data.Slice(1, 1)[0],
            ShareholdersFeePercentBps = data.Slice(2, 1)[0],
            PercentScale = BinaryPrimitives.ReadUInt16LittleEndian(data[4..]),
            ReturnCode = BinaryPrimitives.ReadUInt64LittleEndian(data[8..])
        };
    }
}

// ═══ Function: GetRooms (inputType=2) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetRoomsInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetRoomsOutput : ISmartContractOutput<GetRoomsOutput>
{
    public byte[] Rooms { get; init; }
    public byte ReturnCode { get; init; }

    public static GetRoomsOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetRoomsOutput
        {
            Rooms = [] /* unknown struct array RoomInfo */,
            ReturnCode = data.Slice(0, 1)[0]
        };
    }
}

// ═══ Function: GetTTLHours (inputType=3) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetTTLHoursInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetTTLHoursOutput : ISmartContractOutput<GetTTLHoursOutput>
{
    public byte TtlHours { get; init; }
    public byte ReturnCode { get; init; }

    public static GetTTLHoursOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetTTLHoursOutput
        {
            TtlHours = data.Slice(0, 1)[0],
            ReturnCode = data.Slice(1, 1)[0]
        };
    }
}

// ═══ Function: GetUserProfile (inputType=4) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetUserProfileInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetUserProfileOutput : ISmartContractOutput<GetUserProfileOutput>
{
    public byte[] RoomId { get; init; }
    public ulong DepositedAmount { get; init; }
    public ulong Locked { get; init; }
    public ulong Stake { get; init; }
    public ulong RaiseStep { get; init; }
    public ulong MaxStake { get; init; }
    public byte ReturnCode { get; init; }

    public static GetUserProfileOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetUserProfileOutput
        {
            RoomId = data[0..].Slice(0, 32).ToArray(),
            DepositedAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[32..]),
            Locked = BinaryPrimitives.ReadUInt64LittleEndian(data[40..]),
            Stake = BinaryPrimitives.ReadUInt64LittleEndian(data[48..]),
            RaiseStep = BinaryPrimitives.ReadUInt64LittleEndian(data[56..]),
            MaxStake = BinaryPrimitives.ReadUInt64LittleEndian(data[64..]),
            ReturnCode = data.Slice(72, 1)[0]
        };
    }
}

// ═══ Procedure: CreateRoom (inputType=1) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class CreateRoomPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 56;

    public ushort InputType => 1;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] AllowedPlayer { get; init; }
    public long Stake { get; init; }
    public long RaiseStep { get; init; }
    public long MaxStake { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        AllowedPlayer.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(32), Stake);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(40), RaiseStep);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(48), MaxStake);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct CreateRoomOutput : ISmartContractOutput<CreateRoomOutput>
{
    public byte ReturnCode { get; init; }

    public static CreateRoomOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new CreateRoomOutput
        {
            ReturnCode = data.Slice(0, 1)[0]
        };
    }
}

// ═══ Procedure: ConnectToRoom (inputType=2) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class ConnectToRoomPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 32;

    public ushort InputType => 2;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] RoomId { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        RoomId.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct ConnectToRoomOutput : ISmartContractOutput<ConnectToRoomOutput>
{
    public byte ReturnCode { get; init; }

    public static ConnectToRoomOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new ConnectToRoomOutput
        {
            ReturnCode = data.Slice(0, 1)[0]
        };
    }
}

// ═══ Procedure: SetPercentFees (inputType=3) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class SetPercentFeesPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 3;

    public ushort InputType => 3;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public byte DevFeePercentBps { get; init; }
    public byte BurnFeePercentBps { get; init; }
    public byte ShareholdersFeePercentBps { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        bytes.AsSpan(0, 1)[0] = DevFeePercentBps;
        bytes.AsSpan(1, 1)[0] = BurnFeePercentBps;
        bytes.AsSpan(2, 1)[0] = ShareholdersFeePercentBps;
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct SetPercentFeesOutput : ISmartContractOutput<SetPercentFeesOutput>
{
    public byte ReturnCode { get; init; }

    public static SetPercentFeesOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new SetPercentFeesOutput
        {
            ReturnCode = data.Slice(0, 1)[0]
        };
    }
}

// ═══ Procedure: SetTTLHours (inputType=4) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class SetTTLHoursPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 1;

    public ushort InputType => 4;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public byte TtlHours { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        bytes.AsSpan(0, 1)[0] = TtlHours;
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct SetTTLHoursOutput : ISmartContractOutput<SetTTLHoursOutput>
{
    public byte ReturnCode { get; init; }

    public static SetTTLHoursOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new SetTTLHoursOutput
        {
            ReturnCode = data.Slice(0, 1)[0]
        };
    }
}

// ═══ Procedure: Deposit (inputType=5) ═══

/// <summary>Input for procedure (empty payload).</summary>
public sealed class DepositPayload : ITransactionPayload, ISmartContractInput
{
    public ushort InputType => 5;
    public ushort InputSize => 0;
    public int SerializedSize => 0;
    public byte[] GetPayloadBytes() => [];
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct DepositOutput : ISmartContractOutput<DepositOutput>
{
    public byte ReturnCode { get; init; }

    public static DepositOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new DepositOutput
        {
            ReturnCode = data.Slice(0, 1)[0]
        };
    }
}

// ═══ Procedure: Withdraw (inputType=6) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class WithdrawPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 8;

    public ushort InputType => 6;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public long Amount { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(0), Amount);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct WithdrawOutput : ISmartContractOutput<WithdrawOutput>
{
    public byte ReturnCode { get; init; }

    public static WithdrawOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new WithdrawOutput
        {
            ReturnCode = data.Slice(0, 1)[0]
        };
    }
}
