// <auto-generated>
// Generated by Qubic.ContractGen from Qx.h.
// Do not edit manually. Re-run the generator after updating deps/qubic-core.
// </auto-generated>

using System.Buffers.Binary;
using Qubic.Core.Contracts;
using Qubic.Core.Payloads;

namespace Qubic.Core.Contracts.Qx;

/// <summary>Qx contract (index 1).</summary>
public static class QxContract
{
    /// <summary>Contract index on the Qubic network.</summary>
    public const int ContractIndex = 1;

    /// <summary>Gets the 32-byte contract public key.</summary>
    public static byte[] GetPublicKey() => QubicContracts.GetContractPublicKey(ContractIndex);

    /// <summary>Read-only query function IDs.</summary>
    public static class Functions
    {
        /// <summary>Fees (inputType=1).</summary>
        public const uint Fees = 1;
        /// <summary>AssetAskOrders (inputType=2).</summary>
        public const uint AssetAskOrders = 2;
        /// <summary>AssetBidOrders (inputType=3).</summary>
        public const uint AssetBidOrders = 3;
        /// <summary>EntityAskOrders (inputType=4).</summary>
        public const uint EntityAskOrders = 4;
        /// <summary>EntityBidOrders (inputType=5).</summary>
        public const uint EntityBidOrders = 5;
    }

    /// <summary>State-mutating procedure IDs.</summary>
    public static class Procedures
    {
        /// <summary>IssueAsset (inputType=1).</summary>
        public const uint IssueAsset = 1;
        /// <summary>TransferShareOwnershipAndPossession (inputType=2).</summary>
        public const uint TransferShareOwnershipAndPossession = 2;
        /// <summary>AddToAskOrder (inputType=5).</summary>
        public const uint AddToAskOrder = 5;
        /// <summary>AddToBidOrder (inputType=6).</summary>
        public const uint AddToBidOrder = 6;
        /// <summary>RemoveFromAskOrder (inputType=7).</summary>
        public const uint RemoveFromAskOrder = 7;
        /// <summary>RemoveFromBidOrder (inputType=8).</summary>
        public const uint RemoveFromBidOrder = 8;
        /// <summary>TransferShareManagementRights (inputType=9).</summary>
        public const uint TransferShareManagementRights = 9;
    }
}

// ═══ Function: Fees (inputType=1) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct FeesInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct FeesOutput : ISmartContractOutput<FeesOutput>
{
    public uint AssetIssuanceFee { get; init; }
    public uint TransferFee { get; init; }
    public uint TradeFee { get; init; }

    public static FeesOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new FeesOutput
        {
            AssetIssuanceFee = BinaryPrimitives.ReadUInt32LittleEndian(data[0..]),
            TransferFee = BinaryPrimitives.ReadUInt32LittleEndian(data[4..]),
            TradeFee = BinaryPrimitives.ReadUInt32LittleEndian(data[8..])
        };
    }
}

// ═══ Function: AssetAskOrders (inputType=2) ═══

/// <summary>Nested type from AssetAskOrders.</summary>
public readonly struct AssetAskOrdersOrder
{
    public const int Size = 48;

    public required byte[] Entity { get; init; }
    public long Price { get; init; }
    public long NumberOfShares { get; init; }

    public static AssetAskOrdersOrder ReadFrom(ReadOnlySpan<byte> data)
    {
        return new AssetAskOrdersOrder
        {
            Entity = data[0..].Slice(0, 32).ToArray(),
            Price = BinaryPrimitives.ReadInt64LittleEndian(data[32..]),
            NumberOfShares = BinaryPrimitives.ReadInt64LittleEndian(data[40..])
        };
    }
}

/// <summary>Input for query.</summary>
public readonly struct AssetAskOrdersInput : ISmartContractInput
{
    public const int Size = 48;

    public int SerializedSize => Size;

    public required byte[] Issuer { get; init; }
    public ulong AssetName { get; init; }
    public ulong Offset { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Issuer.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(32), AssetName);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(40), Offset);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct AssetAskOrdersOutput : ISmartContractOutput<AssetAskOrdersOutput>
{
    public AssetAskOrdersOrder[] Orders { get; init; }

    public static AssetAskOrdersOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var orders = new AssetAskOrdersOrder[256];
        for (int i = 0; i < 256; i++)
        {
            orders[i] = AssetAskOrdersOrder.ReadFrom(data.Slice(0 + i * AssetAskOrdersOrder.Size, AssetAskOrdersOrder.Size));
        }
        return new AssetAskOrdersOutput
        {
            Orders = orders
        };
    }
}

// ═══ Function: AssetBidOrders (inputType=3) ═══

/// <summary>Nested type from AssetBidOrders.</summary>
public readonly struct AssetBidOrdersOrder
{
    public const int Size = 48;

    public required byte[] Entity { get; init; }
    public long Price { get; init; }
    public long NumberOfShares { get; init; }

    public static AssetBidOrdersOrder ReadFrom(ReadOnlySpan<byte> data)
    {
        return new AssetBidOrdersOrder
        {
            Entity = data[0..].Slice(0, 32).ToArray(),
            Price = BinaryPrimitives.ReadInt64LittleEndian(data[32..]),
            NumberOfShares = BinaryPrimitives.ReadInt64LittleEndian(data[40..])
        };
    }
}

/// <summary>Input for query.</summary>
public readonly struct AssetBidOrdersInput : ISmartContractInput
{
    public const int Size = 48;

    public int SerializedSize => Size;

    public required byte[] Issuer { get; init; }
    public ulong AssetName { get; init; }
    public ulong Offset { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Issuer.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(32), AssetName);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(40), Offset);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct AssetBidOrdersOutput : ISmartContractOutput<AssetBidOrdersOutput>
{
    public AssetBidOrdersOrder[] Orders { get; init; }

    public static AssetBidOrdersOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var orders = new AssetBidOrdersOrder[256];
        for (int i = 0; i < 256; i++)
        {
            orders[i] = AssetBidOrdersOrder.ReadFrom(data.Slice(0 + i * AssetBidOrdersOrder.Size, AssetBidOrdersOrder.Size));
        }
        return new AssetBidOrdersOutput
        {
            Orders = orders
        };
    }
}

// ═══ Function: EntityAskOrders (inputType=4) ═══

/// <summary>Nested type from EntityAskOrders.</summary>
public readonly struct EntityAskOrdersOrder
{
    public const int Size = 56;

    public required byte[] Issuer { get; init; }
    public ulong AssetName { get; init; }
    public long Price { get; init; }
    public long NumberOfShares { get; init; }

    public static EntityAskOrdersOrder ReadFrom(ReadOnlySpan<byte> data)
    {
        return new EntityAskOrdersOrder
        {
            Issuer = data[0..].Slice(0, 32).ToArray(),
            AssetName = BinaryPrimitives.ReadUInt64LittleEndian(data[32..]),
            Price = BinaryPrimitives.ReadInt64LittleEndian(data[40..]),
            NumberOfShares = BinaryPrimitives.ReadInt64LittleEndian(data[48..])
        };
    }
}

/// <summary>Input for query.</summary>
public readonly struct EntityAskOrdersInput : ISmartContractInput
{
    public const int Size = 40;

    public int SerializedSize => Size;

    public required byte[] Entity { get; init; }
    public ulong Offset { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Entity.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(32), Offset);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct EntityAskOrdersOutput : ISmartContractOutput<EntityAskOrdersOutput>
{
    public EntityAskOrdersOrder[] Orders { get; init; }

    public static EntityAskOrdersOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var orders = new EntityAskOrdersOrder[256];
        for (int i = 0; i < 256; i++)
        {
            orders[i] = EntityAskOrdersOrder.ReadFrom(data.Slice(0 + i * EntityAskOrdersOrder.Size, EntityAskOrdersOrder.Size));
        }
        return new EntityAskOrdersOutput
        {
            Orders = orders
        };
    }
}

// ═══ Function: EntityBidOrders (inputType=5) ═══

/// <summary>Nested type from EntityBidOrders.</summary>
public readonly struct EntityBidOrdersOrder
{
    public const int Size = 56;

    public required byte[] Issuer { get; init; }
    public ulong AssetName { get; init; }
    public long Price { get; init; }
    public long NumberOfShares { get; init; }

    public static EntityBidOrdersOrder ReadFrom(ReadOnlySpan<byte> data)
    {
        return new EntityBidOrdersOrder
        {
            Issuer = data[0..].Slice(0, 32).ToArray(),
            AssetName = BinaryPrimitives.ReadUInt64LittleEndian(data[32..]),
            Price = BinaryPrimitives.ReadInt64LittleEndian(data[40..]),
            NumberOfShares = BinaryPrimitives.ReadInt64LittleEndian(data[48..])
        };
    }
}

/// <summary>Input for query.</summary>
public readonly struct EntityBidOrdersInput : ISmartContractInput
{
    public const int Size = 40;

    public int SerializedSize => Size;

    public required byte[] Entity { get; init; }
    public ulong Offset { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Entity.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(32), Offset);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct EntityBidOrdersOutput : ISmartContractOutput<EntityBidOrdersOutput>
{
    public EntityBidOrdersOrder[] Orders { get; init; }

    public static EntityBidOrdersOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var orders = new EntityBidOrdersOrder[256];
        for (int i = 0; i < 256; i++)
        {
            orders[i] = EntityBidOrdersOrder.ReadFrom(data.Slice(0 + i * EntityBidOrdersOrder.Size, EntityBidOrdersOrder.Size));
        }
        return new EntityBidOrdersOutput
        {
            Orders = orders
        };
    }
}

// ═══ Procedure: IssueAsset (inputType=1) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class IssueAssetPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 32;

    public ushort InputType => 1;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong AssetName { get; init; }
    public long NumberOfShares { get; init; }
    public ulong UnitOfMeasurement { get; init; }
    public sbyte NumberOfDecimalPlaces { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), AssetName);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(8), NumberOfShares);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(16), UnitOfMeasurement);
        bytes.AsSpan(24, 1)[0] = (byte)NumberOfDecimalPlaces;
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct IssueAssetOutput : ISmartContractOutput<IssueAssetOutput>
{
    public long IssuedNumberOfShares { get; init; }

    public static IssueAssetOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new IssueAssetOutput
        {
            IssuedNumberOfShares = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: TransferShareOwnershipAndPossession (inputType=2) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class TransferShareOwnershipAndPossessionPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 80;

    public ushort InputType => 2;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] Issuer { get; init; }
    public required byte[] NewOwnerAndPossessor { get; init; }
    public ulong AssetName { get; init; }
    public long NumberOfShares { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Issuer.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        NewOwnerAndPossessor.AsSpan(0, 32).CopyTo(bytes.AsSpan(32));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(64), AssetName);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(72), NumberOfShares);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct TransferShareOwnershipAndPossessionOutput : ISmartContractOutput<TransferShareOwnershipAndPossessionOutput>
{
    public long TransferredNumberOfShares { get; init; }

    public static TransferShareOwnershipAndPossessionOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new TransferShareOwnershipAndPossessionOutput
        {
            TransferredNumberOfShares = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: AddToAskOrder (inputType=5) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class AddToAskOrderPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 56;

    public ushort InputType => 5;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] Issuer { get; init; }
    public ulong AssetName { get; init; }
    public long Price { get; init; }
    public long NumberOfShares { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Issuer.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(32), AssetName);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(40), Price);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(48), NumberOfShares);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct AddToAskOrderOutput : ISmartContractOutput<AddToAskOrderOutput>
{
    public long AddedNumberOfShares { get; init; }

    public static AddToAskOrderOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new AddToAskOrderOutput
        {
            AddedNumberOfShares = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: AddToBidOrder (inputType=6) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class AddToBidOrderPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 56;

    public ushort InputType => 6;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] Issuer { get; init; }
    public ulong AssetName { get; init; }
    public long Price { get; init; }
    public long NumberOfShares { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Issuer.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(32), AssetName);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(40), Price);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(48), NumberOfShares);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct AddToBidOrderOutput : ISmartContractOutput<AddToBidOrderOutput>
{
    public long AddedNumberOfShares { get; init; }

    public static AddToBidOrderOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new AddToBidOrderOutput
        {
            AddedNumberOfShares = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: RemoveFromAskOrder (inputType=7) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class RemoveFromAskOrderPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 56;

    public ushort InputType => 7;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] Issuer { get; init; }
    public ulong AssetName { get; init; }
    public long Price { get; init; }
    public long NumberOfShares { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Issuer.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(32), AssetName);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(40), Price);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(48), NumberOfShares);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct RemoveFromAskOrderOutput : ISmartContractOutput<RemoveFromAskOrderOutput>
{
    public long RemovedNumberOfShares { get; init; }

    public static RemoveFromAskOrderOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new RemoveFromAskOrderOutput
        {
            RemovedNumberOfShares = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: RemoveFromBidOrder (inputType=8) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class RemoveFromBidOrderPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 56;

    public ushort InputType => 8;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] Issuer { get; init; }
    public ulong AssetName { get; init; }
    public long Price { get; init; }
    public long NumberOfShares { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Issuer.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(32), AssetName);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(40), Price);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(48), NumberOfShares);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct RemoveFromBidOrderOutput : ISmartContractOutput<RemoveFromBidOrderOutput>
{
    public long RemovedNumberOfShares { get; init; }

    public static RemoveFromBidOrderOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new RemoveFromBidOrderOutput
        {
            RemovedNumberOfShares = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: TransferShareManagementRights (inputType=9) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class TransferShareManagementRightsPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 56;

    public ushort InputType => 9;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required QubicAsset Asset { get; init; }
    public long NumberOfShares { get; init; }
    public uint NewManagingContractIndex { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Asset.WriteTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(40), NumberOfShares);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(48), NewManagingContractIndex);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct TransferShareManagementRightsOutput : ISmartContractOutput<TransferShareManagementRightsOutput>
{
    public long TransferredNumberOfShares { get; init; }

    public static TransferShareManagementRightsOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new TransferShareManagementRightsOutput
        {
            TransferredNumberOfShares = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}
