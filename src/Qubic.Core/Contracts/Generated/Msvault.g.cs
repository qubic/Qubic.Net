// <auto-generated>
// Generated by Qubic.ContractGen from MsVault.h.
// Do not edit manually. Re-run the generator after updating deps/qubic-core.
// </auto-generated>

using System.Buffers.Binary;
using Qubic.Core.Contracts;
using Qubic.Core.Payloads;

namespace Qubic.Core.Contracts.Msvault;

/// <summary>Msvault contract (index 11).</summary>
public static class MsvaultContract
{
    /// <summary>Contract index on the Qubic network.</summary>
    public const int ContractIndex = 11;

    /// <summary>Gets the 32-byte contract public key.</summary>
    public static byte[] GetPublicKey() => QubicContracts.GetContractPublicKey(ContractIndex);

    /// <summary>Read-only query function IDs.</summary>
    public static class Functions
    {
        /// <summary>getVaults (inputType=5).</summary>
        public const uint GetVaults = 5;
        /// <summary>getReleaseStatus (inputType=6).</summary>
        public const uint GetReleaseStatus = 6;
        /// <summary>getBalanceOf (inputType=7).</summary>
        public const uint GetBalanceOf = 7;
        /// <summary>getVaultName (inputType=8).</summary>
        public const uint GetVaultName = 8;
        /// <summary>getRevenueInfo (inputType=9).</summary>
        public const uint GetRevenueInfo = 9;
        /// <summary>getFees (inputType=10).</summary>
        public const uint GetFees = 10;
        /// <summary>getVaultOwners (inputType=11).</summary>
        public const uint GetVaultOwners = 11;
        /// <summary>isShareHolder (inputType=12).</summary>
        public const uint IsShareHolder = 12;
        /// <summary>getFeeVotes (inputType=14).</summary>
        public const uint GetFeeVotes = 14;
        /// <summary>getFeeVotesOwner (inputType=15).</summary>
        public const uint GetFeeVotesOwner = 15;
        /// <summary>getFeeVotesScore (inputType=16).</summary>
        public const uint GetFeeVotesScore = 16;
        /// <summary>getUniqueFeeVotes (inputType=17).</summary>
        public const uint GetUniqueFeeVotes = 17;
        /// <summary>getUniqueFeeVotesRanking (inputType=18).</summary>
        public const uint GetUniqueFeeVotesRanking = 18;
        /// <summary>getVaultAssetBalances (inputType=22).</summary>
        public const uint GetVaultAssetBalances = 22;
        /// <summary>getAssetReleaseStatus (inputType=23).</summary>
        public const uint GetAssetReleaseStatus = 23;
        /// <summary>getManagedAssetBalance (inputType=24).</summary>
        public const uint GetManagedAssetBalance = 24;
    }

    /// <summary>State-mutating procedure IDs.</summary>
    public static class Procedures
    {
        /// <summary>registerVault (inputType=1).</summary>
        public const uint RegisterVault = 1;
        /// <summary>deposit (inputType=2).</summary>
        public const uint Deposit = 2;
        /// <summary>releaseTo (inputType=3).</summary>
        public const uint ReleaseTo = 3;
        /// <summary>resetRelease (inputType=4).</summary>
        public const uint ResetRelease = 4;
        /// <summary>voteFeeChange (inputType=13).</summary>
        public const uint VoteFeeChange = 13;
        /// <summary>depositAsset (inputType=19).</summary>
        public const uint DepositAsset = 19;
        /// <summary>releaseAssetTo (inputType=20).</summary>
        public const uint ReleaseAssetTo = 20;
        /// <summary>resetAssetRelease (inputType=21).</summary>
        public const uint ResetAssetRelease = 21;
        /// <summary>revokeAssetManagementRights (inputType=25).</summary>
        public const uint RevokeAssetManagementRights = 25;
    }
}

// ═══ Function: getVaults (inputType=5) ═══

/// <summary>Input for query.</summary>
public readonly struct GetVaultsInput : ISmartContractInput
{
    public const int Size = 32;

    public int SerializedSize => Size;

    public required byte[] PublicKey { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        PublicKey.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetVaultsOutput : ISmartContractOutput<GetVaultsOutput>
{
    public ulong NumberOfVaults { get; init; }
    public ulong[] VaultIds { get; init; }
    public byte[][] VaultNames { get; init; }

    public static GetVaultsOutput FromBytes(ReadOnlySpan<byte> data)
    {
        // Layout: uint64 numberOfVaults(8) + Array<uint64,8> vaultIds(64) + Array<id,8> vaultNames(256) = 328 bytes
        var vaultIds = new ulong[8];
        for (int i = 0; i < 8; i++)
        {
            vaultIds[i] = BinaryPrimitives.ReadUInt64LittleEndian(data[(8 + i * 8)..]);
        }
        var vaultNames = new byte[8][];
        for (int i = 0; i < 8; i++)
        {
            vaultNames[i] = data[(72 + i * 32)..].Slice(0, 32).ToArray();
        }
        return new GetVaultsOutput
        {
            NumberOfVaults = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            VaultIds = vaultIds,
            VaultNames = vaultNames
        };
    }
}

// ═══ Function: getReleaseStatus (inputType=6) ═══

/// <summary>Input for query.</summary>
public readonly struct GetReleaseStatusInput : ISmartContractInput
{
    public const int Size = 8;

    public int SerializedSize => Size;

    public ulong VaultId { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), VaultId);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetReleaseStatusOutput : ISmartContractOutput<GetReleaseStatusOutput>
{
    public ulong Status { get; init; }
    public ulong[] Amounts { get; init; }
    public byte[][] Destinations { get; init; }

    public static GetReleaseStatusOutput FromBytes(ReadOnlySpan<byte> data)
    {
        // Layout: uint64 status(8) + Array<uint64,16> amounts(128) + Array<id,16> destinations(512) = 648 bytes
        var amounts = new ulong[16];
        for (int i = 0; i < 16; i++)
        {
            amounts[i] = BinaryPrimitives.ReadUInt64LittleEndian(data[(8 + i * 8)..]);
        }
        var destinations = new byte[16][];
        for (int i = 0; i < 16; i++)
        {
            destinations[i] = data[(136 + i * 32)..].Slice(0, 32).ToArray();
        }
        return new GetReleaseStatusOutput
        {
            Status = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            Amounts = amounts,
            Destinations = destinations
        };
    }
}

// ═══ Function: getBalanceOf (inputType=7) ═══

/// <summary>Input for query.</summary>
public readonly struct GetBalanceOfInput : ISmartContractInput
{
    public const int Size = 8;

    public int SerializedSize => Size;

    public ulong VaultId { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), VaultId);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetBalanceOfOutput : ISmartContractOutput<GetBalanceOfOutput>
{
    public ulong Status { get; init; }
    public long Balance { get; init; }

    public static GetBalanceOfOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetBalanceOfOutput
        {
            Status = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            Balance = BinaryPrimitives.ReadInt64LittleEndian(data[8..])
        };
    }
}

// ═══ Function: getVaultName (inputType=8) ═══

/// <summary>Input for query.</summary>
public readonly struct GetVaultNameInput : ISmartContractInput
{
    public const int Size = 8;

    public int SerializedSize => Size;

    public ulong VaultId { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), VaultId);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetVaultNameOutput : ISmartContractOutput<GetVaultNameOutput>
{
    public ulong Status { get; init; }
    public byte[] VaultName { get; init; }

    public static GetVaultNameOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetVaultNameOutput
        {
            Status = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            VaultName = data[8..].Slice(0, 32).ToArray()
        };
    }
}

// ═══ Function: getRevenueInfo (inputType=9) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetRevenueInfoInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetRevenueInfoOutput : ISmartContractOutput<GetRevenueInfoOutput>
{
    public ulong NumberOfActiveVaults { get; init; }
    public ulong TotalRevenue { get; init; }
    public ulong TotalDistributedToShareholders { get; init; }
    public ulong BurnedAmount { get; init; }

    public static GetRevenueInfoOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetRevenueInfoOutput
        {
            NumberOfActiveVaults = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            TotalRevenue = BinaryPrimitives.ReadUInt64LittleEndian(data[8..]),
            TotalDistributedToShareholders = BinaryPrimitives.ReadUInt64LittleEndian(data[16..]),
            BurnedAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[24..])
        };
    }
}

// ═══ Function: getFees (inputType=10) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetFeesInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetFeesOutput : ISmartContractOutput<GetFeesOutput>
{
    public ulong RegisteringFee { get; init; }
    public ulong ReleaseFee { get; init; }
    public ulong ReleaseResetFee { get; init; }
    public ulong HoldingFee { get; init; }
    public ulong DepositFee { get; init; }
    public ulong BurnFee { get; init; }

    public static GetFeesOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetFeesOutput
        {
            RegisteringFee = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            ReleaseFee = BinaryPrimitives.ReadUInt64LittleEndian(data[8..]),
            ReleaseResetFee = BinaryPrimitives.ReadUInt64LittleEndian(data[16..]),
            HoldingFee = BinaryPrimitives.ReadUInt64LittleEndian(data[24..]),
            DepositFee = BinaryPrimitives.ReadUInt64LittleEndian(data[32..]),
            BurnFee = BinaryPrimitives.ReadUInt64LittleEndian(data[40..])
        };
    }
}

// ═══ Function: getVaultOwners (inputType=11) ═══

/// <summary>Input for query.</summary>
public readonly struct GetVaultOwnersInput : ISmartContractInput
{
    public const int Size = 8;

    public int SerializedSize => Size;

    public ulong VaultId { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), VaultId);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetVaultOwnersOutput : ISmartContractOutput<GetVaultOwnersOutput>
{
    public ulong Status { get; init; }
    public ulong NumberOfOwners { get; init; }
    public byte[][] Owners { get; init; }
    public ulong RequiredApprovals { get; init; }

    public static GetVaultOwnersOutput FromBytes(ReadOnlySpan<byte> data)
    {
        // Layout: uint64 status(8) + uint64 numOwners(8) + Array<id,16> owners(512) + uint64 reqApprovals(8) = 536 bytes
        var owners = new byte[16][];
        for (int i = 0; i < 16; i++)
        {
            owners[i] = data[(16 + i * 32)..].Slice(0, 32).ToArray();
        }
        return new GetVaultOwnersOutput
        {
            Status = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            NumberOfOwners = BinaryPrimitives.ReadUInt64LittleEndian(data[8..]),
            Owners = owners,
            RequiredApprovals = BinaryPrimitives.ReadUInt64LittleEndian(data[528..])
        };
    }
}

// ═══ Function: isShareHolder (inputType=12) ═══

/// <summary>Input for query.</summary>
public readonly struct IsShareHolderInput : ISmartContractInput
{
    public const int Size = 32;

    public int SerializedSize => Size;

    public required byte[] Candidate { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Candidate.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct IsShareHolderOutput : ISmartContractOutput<IsShareHolderOutput>
{
    public ulong Result { get; init; }

    public static IsShareHolderOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new IsShareHolderOutput
        {
            Result = BinaryPrimitives.ReadUInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Function: getFeeVotes (inputType=14) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetFeeVotesInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetFeeVotesOutput : ISmartContractOutput<GetFeeVotesOutput>
{
    public ulong Status { get; init; }
    public ulong NumberOfFeeVotes { get; init; }
    public byte[] FeeVotes { get; init; }

    public static GetFeeVotesOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetFeeVotesOutput
        {
            Status = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            NumberOfFeeVotes = BinaryPrimitives.ReadUInt64LittleEndian(data[8..]),
            FeeVotes = [] /* unknown struct array MsVaultFeeVote */
        };
    }
}

// ═══ Function: getFeeVotesOwner (inputType=15) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetFeeVotesOwnerInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetFeeVotesOwnerOutput : ISmartContractOutput<GetFeeVotesOwnerOutput>
{
    public ulong Status { get; init; }
    public ulong NumberOfFeeVotes { get; init; }
    public byte[][] FeeVotesOwner { get; init; }

    public static GetFeeVotesOwnerOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var feeVotesOwner = new byte[64][];
        for (int i = 0; i < 64; i++)
        {
            feeVotesOwner[i] = data[(16 + i * 32)..].Slice(0, 32).ToArray();
        }
        return new GetFeeVotesOwnerOutput
        {
            Status = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            NumberOfFeeVotes = BinaryPrimitives.ReadUInt64LittleEndian(data[8..]),
            FeeVotesOwner = feeVotesOwner
        };
    }
}

// ═══ Function: getFeeVotesScore (inputType=16) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetFeeVotesScoreInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetFeeVotesScoreOutput : ISmartContractOutput<GetFeeVotesScoreOutput>
{
    public ulong Status { get; init; }
    public ulong NumberOfFeeVotes { get; init; }
    public ulong[] FeeVotesScore { get; init; }

    public static GetFeeVotesScoreOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var feeVotesScore = new ulong[64];
        for (int i = 0; i < 64; i++)
        {
            feeVotesScore[i] = BinaryPrimitives.ReadUInt64LittleEndian(data[(16 + i * 8)..]);
        }
        return new GetFeeVotesScoreOutput
        {
            Status = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            NumberOfFeeVotes = BinaryPrimitives.ReadUInt64LittleEndian(data[8..]),
            FeeVotesScore = feeVotesScore
        };
    }
}

// ═══ Function: getUniqueFeeVotes (inputType=17) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetUniqueFeeVotesInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetUniqueFeeVotesOutput : ISmartContractOutput<GetUniqueFeeVotesOutput>
{
    public ulong Status { get; init; }
    public ulong NumberOfUniqueFeeVotes { get; init; }
    public byte[] UniqueFeeVotes { get; init; }

    public static GetUniqueFeeVotesOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetUniqueFeeVotesOutput
        {
            Status = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            NumberOfUniqueFeeVotes = BinaryPrimitives.ReadUInt64LittleEndian(data[8..]),
            UniqueFeeVotes = [] /* unknown struct array MsVaultFeeVote */
        };
    }
}

// ═══ Function: getUniqueFeeVotesRanking (inputType=18) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetUniqueFeeVotesRankingInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetUniqueFeeVotesRankingOutput : ISmartContractOutput<GetUniqueFeeVotesRankingOutput>
{
    public ulong Status { get; init; }
    public ulong NumberOfUniqueFeeVotes { get; init; }
    public ulong[] UniqueFeeVotesRanking { get; init; }

    public static GetUniqueFeeVotesRankingOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var uniqueFeeVotesRanking = new ulong[64];
        for (int i = 0; i < 64; i++)
        {
            uniqueFeeVotesRanking[i] = BinaryPrimitives.ReadUInt64LittleEndian(data[(16 + i * 8)..]);
        }
        return new GetUniqueFeeVotesRankingOutput
        {
            Status = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            NumberOfUniqueFeeVotes = BinaryPrimitives.ReadUInt64LittleEndian(data[8..]),
            UniqueFeeVotesRanking = uniqueFeeVotesRanking
        };
    }
}

// ═══ Function: getVaultAssetBalances (inputType=22) ═══

/// <summary>Input for query.</summary>
public readonly struct GetVaultAssetBalancesInput : ISmartContractInput
{
    public const int Size = 8;

    public int SerializedSize => Size;

    public ulong VaultId { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), VaultId);
        return bytes;
    }
}

/// <summary>An asset balance entry: Asset(40 bytes) + uint64 balance(8 bytes) = 48 bytes.</summary>
public readonly struct AssetBalanceEntry
{
    public QubicAsset Asset { get; init; }
    public ulong Balance { get; init; }

    public static AssetBalanceEntry ReadFrom(ReadOnlySpan<byte> data)
    {
        return new AssetBalanceEntry
        {
            Asset = QubicAsset.ReadFrom(data),
            Balance = BinaryPrimitives.ReadUInt64LittleEndian(data[40..])
        };
    }
}

/// <summary>Output.</summary>
public readonly struct GetVaultAssetBalancesOutput : ISmartContractOutput<GetVaultAssetBalancesOutput>
{
    public ulong Status { get; init; }
    public ulong NumberOfAssetTypes { get; init; }
    /// <summary>Fixed array of 8 asset balance entries (MSVAULT_MAX_ASSET_TYPES).</summary>
    public AssetBalanceEntry[] AssetBalances { get; init; }

    public static GetVaultAssetBalancesOutput FromBytes(ReadOnlySpan<byte> data)
    {
        // Layout: uint64 status(8) + uint64 numTypes(8) + Array<AssetBalance,8>(384) = 400 bytes
        var assetBalances = new AssetBalanceEntry[8];
        for (int i = 0; i < 8; i++)
        {
            assetBalances[i] = AssetBalanceEntry.ReadFrom(data[(16 + i * 48)..]);
        }
        return new GetVaultAssetBalancesOutput
        {
            Status = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            NumberOfAssetTypes = BinaryPrimitives.ReadUInt64LittleEndian(data[8..]),
            AssetBalances = assetBalances
        };
    }
}

// ═══ Function: getAssetReleaseStatus (inputType=23) ═══

/// <summary>Input for query.</summary>
public readonly struct GetAssetReleaseStatusInput : ISmartContractInput
{
    public const int Size = 8;

    public int SerializedSize => Size;

    public ulong VaultId { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), VaultId);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetAssetReleaseStatusOutput : ISmartContractOutput<GetAssetReleaseStatusOutput>
{
    public ulong Status { get; init; }
    public QubicAsset[] Assets { get; init; }
    public ulong[] Amounts { get; init; }
    public byte[][] Destinations { get; init; }

    public static GetAssetReleaseStatusOutput FromBytes(ReadOnlySpan<byte> data)
    {
        // Layout: uint64 status(8) + Array<Asset,16>(640) + Array<uint64,16>(128) + Array<id,16>(512) = 1288 bytes
        var assets = new QubicAsset[16];
        for (int i = 0; i < 16; i++)
        {
            assets[i] = QubicAsset.ReadFrom(data[(8 + i * 40)..]);
        }
        var amounts = new ulong[16];
        for (int i = 0; i < 16; i++)
        {
            amounts[i] = BinaryPrimitives.ReadUInt64LittleEndian(data[(648 + i * 8)..]);
        }
        var destinations = new byte[16][];
        for (int i = 0; i < 16; i++)
        {
            destinations[i] = data[(776 + i * 32)..].Slice(0, 32).ToArray();
        }
        return new GetAssetReleaseStatusOutput
        {
            Status = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            Assets = assets,
            Amounts = amounts,
            Destinations = destinations
        };
    }
}

// ═══ Function: getManagedAssetBalance (inputType=24) ═══

/// <summary>Input for query.</summary>
public readonly struct GetManagedAssetBalanceInput : ISmartContractInput
{
    public const int Size = 72;

    public int SerializedSize => Size;

    public required QubicAsset Asset { get; init; }
    public required byte[] Owner { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Asset.WriteTo(bytes.AsSpan(0));
        Owner.AsSpan(0, 32).CopyTo(bytes.AsSpan(40));
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetManagedAssetBalanceOutput : ISmartContractOutput<GetManagedAssetBalanceOutput>
{
    public long Balance { get; init; }

    public static GetManagedAssetBalanceOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetManagedAssetBalanceOutput
        {
            Balance = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: registerVault (inputType=1) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class RegisterVaultPayload : ITransactionPayload, ISmartContractInput
{
    /// <summary>32 (vaultName) + 16*32 (owners) + 8 (requiredApprovals) = 552 bytes.</summary>
    public const int Size = 552;

    public ushort InputType => 1;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] VaultName { get; init; }
    /// <summary>Up to 16 owner public keys (32 bytes each). Minimum 2 unique owners required.</summary>
    public required byte[][] Owners { get; init; }
    public ulong RequiredApprovals { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        VaultName.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        for (int i = 0; i < 16 && Owners != null && i < Owners.Length; i++)
        {
            Owners[i].AsSpan(0, 32).CopyTo(bytes.AsSpan(32 + i * 32));
        }
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(544), RequiredApprovals);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct RegisterVaultOutput : ISmartContractOutput<RegisterVaultOutput>
{
    public ulong Status { get; init; }

    public static RegisterVaultOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new RegisterVaultOutput
        {
            Status = BinaryPrimitives.ReadUInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: deposit (inputType=2) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class DepositPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 8;

    public ushort InputType => 2;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong VaultId { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), VaultId);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct DepositOutput : ISmartContractOutput<DepositOutput>
{
    public ulong Status { get; init; }

    public static DepositOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new DepositOutput
        {
            Status = BinaryPrimitives.ReadUInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: releaseTo (inputType=3) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class ReleaseToPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 48;

    public ushort InputType => 3;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong VaultId { get; init; }
    public ulong Amount { get; init; }
    public required byte[] Destination { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), VaultId);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(8), Amount);
        Destination.AsSpan(0, 32).CopyTo(bytes.AsSpan(16));
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct ReleaseToOutput : ISmartContractOutput<ReleaseToOutput>
{
    public ulong Status { get; init; }

    public static ReleaseToOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new ReleaseToOutput
        {
            Status = BinaryPrimitives.ReadUInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: resetRelease (inputType=4) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class ResetReleasePayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 8;

    public ushort InputType => 4;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong VaultId { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), VaultId);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct ResetReleaseOutput : ISmartContractOutput<ResetReleaseOutput>
{
    public ulong Status { get; init; }

    public static ResetReleaseOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new ResetReleaseOutput
        {
            Status = BinaryPrimitives.ReadUInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: voteFeeChange (inputType=13) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class VoteFeeChangePayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 48;

    public ushort InputType => 13;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong NewRegisteringFee { get; init; }
    public ulong NewReleaseFee { get; init; }
    public ulong NewReleaseResetFee { get; init; }
    public ulong NewHoldingFee { get; init; }
    public ulong NewDepositFee { get; init; }
    public ulong BurnFee { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), NewRegisteringFee);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(8), NewReleaseFee);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(16), NewReleaseResetFee);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(24), NewHoldingFee);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(32), NewDepositFee);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(40), BurnFee);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct VoteFeeChangeOutput : ISmartContractOutput<VoteFeeChangeOutput>
{
    public ulong Status { get; init; }

    public static VoteFeeChangeOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new VoteFeeChangeOutput
        {
            Status = BinaryPrimitives.ReadUInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: depositAsset (inputType=19) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class DepositAssetPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 56;

    public ushort InputType => 19;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong VaultId { get; init; }
    public required QubicAsset Asset { get; init; }
    public ulong Amount { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), VaultId);
        Asset.WriteTo(bytes.AsSpan(8));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(48), Amount);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct DepositAssetOutput : ISmartContractOutput<DepositAssetOutput>
{
    public ulong Status { get; init; }

    public static DepositAssetOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new DepositAssetOutput
        {
            Status = BinaryPrimitives.ReadUInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: releaseAssetTo (inputType=20) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class ReleaseAssetToPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 88;

    public ushort InputType => 20;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong VaultId { get; init; }
    public required QubicAsset Asset { get; init; }
    public ulong Amount { get; init; }
    public required byte[] Destination { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), VaultId);
        Asset.WriteTo(bytes.AsSpan(8));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(48), Amount);
        Destination.AsSpan(0, 32).CopyTo(bytes.AsSpan(56));
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct ReleaseAssetToOutput : ISmartContractOutput<ReleaseAssetToOutput>
{
    public ulong Status { get; init; }

    public static ReleaseAssetToOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new ReleaseAssetToOutput
        {
            Status = BinaryPrimitives.ReadUInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: resetAssetRelease (inputType=21) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class ResetAssetReleasePayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 8;

    public ushort InputType => 21;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong VaultId { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), VaultId);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct ResetAssetReleaseOutput : ISmartContractOutput<ResetAssetReleaseOutput>
{
    public ulong Status { get; init; }

    public static ResetAssetReleaseOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new ResetAssetReleaseOutput
        {
            Status = BinaryPrimitives.ReadUInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: revokeAssetManagementRights (inputType=25) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class RevokeAssetManagementRightsPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 48;

    public ushort InputType => 25;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required QubicAsset Asset { get; init; }
    public long NumberOfShares { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Asset.WriteTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(40), NumberOfShares);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct RevokeAssetManagementRightsOutput : ISmartContractOutput<RevokeAssetManagementRightsOutput>
{
    public long TransferredNumberOfShares { get; init; }
    public ulong Status { get; init; }

    public static RevokeAssetManagementRightsOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new RevokeAssetManagementRightsOutput
        {
            TransferredNumberOfShares = BinaryPrimitives.ReadInt64LittleEndian(data[0..]),
            Status = BinaryPrimitives.ReadUInt64LittleEndian(data[8..])
        };
    }
}
