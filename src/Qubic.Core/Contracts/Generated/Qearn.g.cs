// <auto-generated>
// Generated by Qubic.ContractGen from Qearn.h.
// Do not edit manually. Re-run the generator after updating deps/qubic-core.
// </auto-generated>

using System.Buffers.Binary;
using Qubic.Core.Contracts;
using Qubic.Core.Payloads;

namespace Qubic.Core.Contracts.Qearn;

/// <summary>Qearn contract (index 9).</summary>
public static class QearnContract
{
    /// <summary>Contract index on the Qubic network.</summary>
    public const int ContractIndex = 9;

    /// <summary>Gets the 32-byte contract public key.</summary>
    public static byte[] GetPublicKey() => QubicContracts.GetContractPublicKey(ContractIndex);

    /// <summary>Read-only query function IDs.</summary>
    public static class Functions
    {
        /// <summary>getLockInfoPerEpoch (inputType=1).</summary>
        public const uint GetLockInfoPerEpoch = 1;
        /// <summary>getUserLockedInfo (inputType=2).</summary>
        public const uint GetUserLockedInfo = 2;
        /// <summary>getStateOfRound (inputType=3).</summary>
        public const uint GetStateOfRound = 3;
        /// <summary>getUserLockStatus (inputType=4).</summary>
        public const uint GetUserLockStatus = 4;
        /// <summary>getEndedStatus (inputType=5).</summary>
        public const uint GetEndedStatus = 5;
        /// <summary>getStatsPerEpoch (inputType=6).</summary>
        public const uint GetStatsPerEpoch = 6;
        /// <summary>getBurnedAndBoostedStats (inputType=7).</summary>
        public const uint GetBurnedAndBoostedStats = 7;
        /// <summary>getBurnedAndBoostedStatsPerEpoch (inputType=8).</summary>
        public const uint GetBurnedAndBoostedStatsPerEpoch = 8;
    }

    /// <summary>State-mutating procedure IDs.</summary>
    public static class Procedures
    {
        /// <summary>lock (inputType=1).</summary>
        public const uint Lock = 1;
        /// <summary>unlock (inputType=2).</summary>
        public const uint Unlock = 2;
    }
}

// ═══ Function: getLockInfoPerEpoch (inputType=1) ═══

/// <summary>Input for query.</summary>
public readonly struct GetLockInfoPerEpochInput : ISmartContractInput
{
    public const int Size = 4;

    public int SerializedSize => Size;

    public uint Epoch { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), Epoch);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetLockInfoPerEpochOutput : ISmartContractOutput<GetLockInfoPerEpochOutput>
{
    public ulong LockedAmount { get; init; }
    public ulong BonusAmount { get; init; }
    public ulong CurrentLockedAmount { get; init; }
    public ulong CurrentBonusAmount { get; init; }
    public ulong Yield { get; init; }

    public static GetLockInfoPerEpochOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetLockInfoPerEpochOutput
        {
            LockedAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            BonusAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[8..]),
            CurrentLockedAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[16..]),
            CurrentBonusAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[24..]),
            Yield = BinaryPrimitives.ReadUInt64LittleEndian(data[32..])
        };
    }
}

// ═══ Function: getUserLockedInfo (inputType=2) ═══

/// <summary>Input for query.</summary>
public readonly struct GetUserLockedInfoInput : ISmartContractInput
{
    public const int Size = 40;

    public int SerializedSize => Size;

    public required byte[] User { get; init; }
    public uint Epoch { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        User.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(32), Epoch);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetUserLockedInfoOutput : ISmartContractOutput<GetUserLockedInfoOutput>
{
    public ulong LockedAmount { get; init; }

    public static GetUserLockedInfoOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetUserLockedInfoOutput
        {
            LockedAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Function: getStateOfRound (inputType=3) ═══

/// <summary>Input for query.</summary>
public readonly struct GetStateOfRoundInput : ISmartContractInput
{
    public const int Size = 4;

    public int SerializedSize => Size;

    public uint Epoch { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), Epoch);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetStateOfRoundOutput : ISmartContractOutput<GetStateOfRoundOutput>
{
    public uint State { get; init; }

    public static GetStateOfRoundOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetStateOfRoundOutput
        {
            State = BinaryPrimitives.ReadUInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Function: getUserLockStatus (inputType=4) ═══

/// <summary>Input for query.</summary>
public readonly struct GetUserLockStatusInput : ISmartContractInput
{
    public const int Size = 32;

    public int SerializedSize => Size;

    public required byte[] User { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        User.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetUserLockStatusOutput : ISmartContractOutput<GetUserLockStatusOutput>
{
    public ulong Status { get; init; }

    public static GetUserLockStatusOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetUserLockStatusOutput
        {
            Status = BinaryPrimitives.ReadUInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Function: getEndedStatus (inputType=5) ═══

/// <summary>Input for query.</summary>
public readonly struct GetEndedStatusInput : ISmartContractInput
{
    public const int Size = 32;

    public int SerializedSize => Size;

    public required byte[] User { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        User.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetEndedStatusOutput : ISmartContractOutput<GetEndedStatusOutput>
{
    public ulong FullyUnlockedAmount { get; init; }
    public ulong FullyRewardedAmount { get; init; }
    public ulong EarlyUnlockedAmount { get; init; }
    public ulong EarlyRewardedAmount { get; init; }

    public static GetEndedStatusOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetEndedStatusOutput
        {
            FullyUnlockedAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            FullyRewardedAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[8..]),
            EarlyUnlockedAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[16..]),
            EarlyRewardedAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[24..])
        };
    }
}

// ═══ Function: getStatsPerEpoch (inputType=6) ═══

/// <summary>Input for query.</summary>
public readonly struct GetStatsPerEpochInput : ISmartContractInput
{
    public const int Size = 4;

    public int SerializedSize => Size;

    public uint Epoch { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), Epoch);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetStatsPerEpochOutput : ISmartContractOutput<GetStatsPerEpochOutput>
{
    public ulong EarlyUnlockedAmount { get; init; }
    public ulong EarlyUnlockedPercent { get; init; }
    public ulong TotalLockedAmount { get; init; }
    public ulong AverageAPY { get; init; }

    public static GetStatsPerEpochOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetStatsPerEpochOutput
        {
            EarlyUnlockedAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            EarlyUnlockedPercent = BinaryPrimitives.ReadUInt64LittleEndian(data[8..]),
            TotalLockedAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[16..]),
            AverageAPY = BinaryPrimitives.ReadUInt64LittleEndian(data[24..])
        };
    }
}

// ═══ Function: getBurnedAndBoostedStats (inputType=7) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetBurnedAndBoostedStatsInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetBurnedAndBoostedStatsOutput : ISmartContractOutput<GetBurnedAndBoostedStatsOutput>
{
    public ulong BurnedAmount { get; init; }
    public ulong AverageBurnedPercent { get; init; }
    public ulong BoostedAmount { get; init; }
    public ulong AverageBoostedPercent { get; init; }
    public ulong RewardedAmount { get; init; }
    public ulong AverageRewardedPercent { get; init; }

    public static GetBurnedAndBoostedStatsOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetBurnedAndBoostedStatsOutput
        {
            BurnedAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            AverageBurnedPercent = BinaryPrimitives.ReadUInt64LittleEndian(data[8..]),
            BoostedAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[16..]),
            AverageBoostedPercent = BinaryPrimitives.ReadUInt64LittleEndian(data[24..]),
            RewardedAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[32..]),
            AverageRewardedPercent = BinaryPrimitives.ReadUInt64LittleEndian(data[40..])
        };
    }
}

// ═══ Function: getBurnedAndBoostedStatsPerEpoch (inputType=8) ═══

/// <summary>Input for query.</summary>
public readonly struct GetBurnedAndBoostedStatsPerEpochInput : ISmartContractInput
{
    public const int Size = 4;

    public int SerializedSize => Size;

    public uint Epoch { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), Epoch);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetBurnedAndBoostedStatsPerEpochOutput : ISmartContractOutput<GetBurnedAndBoostedStatsPerEpochOutput>
{
    public ulong BurnedAmount { get; init; }
    public ulong BurnedPercent { get; init; }
    public ulong BoostedAmount { get; init; }
    public ulong BoostedPercent { get; init; }
    public ulong RewardedAmount { get; init; }
    public ulong RewardedPercent { get; init; }

    public static GetBurnedAndBoostedStatsPerEpochOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetBurnedAndBoostedStatsPerEpochOutput
        {
            BurnedAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            BurnedPercent = BinaryPrimitives.ReadUInt64LittleEndian(data[8..]),
            BoostedAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[16..]),
            BoostedPercent = BinaryPrimitives.ReadUInt64LittleEndian(data[24..]),
            RewardedAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[32..]),
            RewardedPercent = BinaryPrimitives.ReadUInt64LittleEndian(data[40..])
        };
    }
}

// ═══ Procedure: lock (inputType=1) ═══

/// <summary>Input for procedure (empty payload).</summary>
public sealed class LockPayload : ITransactionPayload, ISmartContractInput
{
    public ushort InputType => 1;
    public ushort InputSize => 0;
    public int SerializedSize => 0;
    public byte[] GetPayloadBytes() => [];
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct LockOutput : ISmartContractOutput<LockOutput>
{
    public int ReturnCode { get; init; }

    public static LockOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new LockOutput
        {
            ReturnCode = BinaryPrimitives.ReadInt32LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: unlock (inputType=2) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class UnlockPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 16;

    public ushort InputType => 2;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong Amount { get; init; }
    public uint LockedEpoch { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), Amount);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(8), LockedEpoch);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct UnlockOutput : ISmartContractOutput<UnlockOutput>
{
    public int ReturnCode { get; init; }

    public static UnlockOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new UnlockOutput
        {
            ReturnCode = BinaryPrimitives.ReadInt32LittleEndian(data[0..])
        };
    }
}
