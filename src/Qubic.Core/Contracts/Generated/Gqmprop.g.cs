// <auto-generated>
// Generated by Qubic.ContractGen from GeneralQuorumProposal.h.
// Do not edit manually. Re-run the generator after updating deps/qubic-core.
// </auto-generated>

using System.Buffers.Binary;
using Qubic.Core.Contracts;
using Qubic.Core.Payloads;

namespace Qubic.Core.Contracts.Gqmprop;

/// <summary>Gqmprop contract (index 6).</summary>
public static class GqmpropContract
{
    /// <summary>Contract index on the Qubic network.</summary>
    public const int ContractIndex = 6;

    /// <summary>Gets the 32-byte contract public key.</summary>
    public static byte[] GetPublicKey() => QubicContracts.GetContractPublicKey(ContractIndex);

    /// <summary>Read-only query function IDs.</summary>
    public static class Functions
    {
        /// <summary>GetProposalIndices (inputType=1).</summary>
        public const uint GetProposalIndices = 1;
        /// <summary>GetProposal (inputType=2).</summary>
        public const uint GetProposal = 2;
        /// <summary>GetVote (inputType=3).</summary>
        public const uint GetVote = 3;
        /// <summary>GetVotingResults (inputType=4).</summary>
        public const uint GetVotingResults = 4;
        /// <summary>GetRevenueDonation (inputType=5).</summary>
        public const uint GetRevenueDonation = 5;
    }

    /// <summary>State-mutating procedure IDs.</summary>
    public static class Procedures
    {
        /// <summary>SetProposal (inputType=1).</summary>
        public const uint SetProposal = 1;
        /// <summary>Vote (inputType=2).</summary>
        public const uint Vote = 2;
    }
}

// ═══ Function: GetProposalIndices (inputType=1) ═══

/// <summary>Input for query.</summary>
public readonly struct GetProposalIndicesInput : ISmartContractInput
{
    public const int Size = 8;

    public int SerializedSize => Size;

    public bool ActiveProposals { get; init; }
    public int PrevProposalIndex { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        bytes.AsSpan(0, 1)[0] = (byte)(ActiveProposals ? 1 : 0);
        BinaryPrimitives.WriteInt32LittleEndian(bytes.AsSpan(4), PrevProposalIndex);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetProposalIndicesOutput : ISmartContractOutput<GetProposalIndicesOutput>
{
    public ushort NumOfIndices { get; init; }
    public ushort[] Indices { get; init; }

    public static GetProposalIndicesOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var indices = new ushort[64];
        for (int i = 0; i < 64; i++)
        {
            indices[i] = BinaryPrimitives.ReadUInt16LittleEndian(data[(2 + i * 2)..]);
        }
        return new GetProposalIndicesOutput
        {
            NumOfIndices = BinaryPrimitives.ReadUInt16LittleEndian(data[0..]),
            Indices = indices
        };
    }
}

// ═══ Function: GetProposal (inputType=2) ═══

/// <summary>Input for query.</summary>
public readonly struct GetProposalInput : ISmartContractInput
{
    public const int Size = 2;

    public int SerializedSize => Size;

    public ushort ProposalIndex { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt16LittleEndian(bytes.AsSpan(0), ProposalIndex);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetProposalOutput : ISmartContractOutput<GetProposalOutput>
{
    public bool Okay { get; init; }
    public byte[] _padding0 { get; init; }
    public byte[] _padding1 { get; init; }
    public byte[] _padding2 { get; init; }
    public byte[] ProposerPubicKey { get; init; }
    public byte[] Proposal { get; init; }

    public static GetProposalOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var _padding0 = new byte[4];
        for (int i = 0; i < 4; i++)
        {
            _padding0[i] = data.Slice(1 + i * 1, 1)[0];
        }
        var _padding1 = new byte[2];
        for (int i = 0; i < 2; i++)
        {
            _padding1[i] = data.Slice(5 + i * 1, 1)[0];
        }
        var _padding2 = new byte[1];
        for (int i = 0; i < 1; i++)
        {
            _padding2[i] = data.Slice(7 + i * 1, 1)[0];
        }
        return new GetProposalOutput
        {
            Okay = (data.Slice(0, 1)[0] != 0),
            _padding0 = _padding0,
            _padding1 = _padding1,
            _padding2 = _padding2,
            ProposerPubicKey = data[8..].Slice(0, 32).ToArray(),
            Proposal = [] /* unknown type ProposalDataT */
        };
    }
}

// ═══ Function: GetVote (inputType=3) ═══

/// <summary>Input for query.</summary>
public readonly struct GetVoteInput : ISmartContractInput
{
    public const int Size = 40;

    public int SerializedSize => Size;

    public required byte[] Voter { get; init; }
    public ushort ProposalIndex { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Voter.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt16LittleEndian(bytes.AsSpan(32), ProposalIndex);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetVoteOutput : ISmartContractOutput<GetVoteOutput>
{
    public bool Okay { get; init; }
    public byte[] Vote { get; init; }

    public static GetVoteOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetVoteOutput
        {
            Okay = (data.Slice(0, 1)[0] != 0),
            Vote = [] /* unknown type ProposalSingleVoteDataV1 */
        };
    }
}

// ═══ Function: GetVotingResults (inputType=4) ═══

/// <summary>Input for query.</summary>
public readonly struct GetVotingResultsInput : ISmartContractInput
{
    public const int Size = 2;

    public int SerializedSize => Size;

    public ushort ProposalIndex { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt16LittleEndian(bytes.AsSpan(0), ProposalIndex);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetVotingResultsOutput : ISmartContractOutput<GetVotingResultsOutput>
{
    public bool Okay { get; init; }
    public byte[] Results { get; init; }

    public static GetVotingResultsOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetVotingResultsOutput
        {
            Okay = (data.Slice(0, 1)[0] != 0),
            Results = [] /* unknown type ProposalSummarizedVotingDataV1 */
        };
    }
}

// ═══ Function: GetRevenueDonation (inputType=5) ═══

/// <summary>Nested type from GetRevenueDonation.</summary>
public readonly struct GetRevenueDonationRevenueDonationEntry
{
    public const int Size = 48;

    public required byte[] DestinationPublicKey { get; init; }
    public long MillionthAmount { get; init; }
    public ushort FirstEpoch { get; init; }

    public static GetRevenueDonationRevenueDonationEntry ReadFrom(ReadOnlySpan<byte> data)
    {
        return new GetRevenueDonationRevenueDonationEntry
        {
            DestinationPublicKey = data[0..].Slice(0, 32).ToArray(),
            MillionthAmount = BinaryPrimitives.ReadInt64LittleEndian(data[32..]),
            FirstEpoch = BinaryPrimitives.ReadUInt16LittleEndian(data[40..])
        };
    }
}

/// <summary>Input for query (empty).</summary>
public readonly struct GetRevenueDonationInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetRevenueDonationOutput : ISmartContractOutput<GetRevenueDonationOutput>
{
    public GetRevenueDonationRevenueDonationEntry[] Entries { get; init; }

    public static GetRevenueDonationOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var entries = new GetRevenueDonationRevenueDonationEntry[128];
        for (int i = 0; i < 128; i++)
        {
            entries[i] = GetRevenueDonationRevenueDonationEntry.ReadFrom(data.Slice(0 + i * GetRevenueDonationRevenueDonationEntry.Size, GetRevenueDonationRevenueDonationEntry.Size));
        }
        return new GetRevenueDonationOutput
        {
            Entries = entries
        };
    }
}

// ═══ Procedure: SetProposal (inputType=1) ═══

/// <summary>Input for procedure (empty payload).</summary>
public sealed class SetProposalPayload : ITransactionPayload, ISmartContractInput
{
    public ushort InputType => 1;
    public ushort InputSize => 0;
    public int SerializedSize => 0;
    public byte[] GetPayloadBytes() => [];
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct SetProposalOutput : ISmartContractOutput<SetProposalOutput>
{
    public ushort ProposalIndex { get; init; }
    public bool Okay { get; init; }

    public static SetProposalOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new SetProposalOutput
        {
            ProposalIndex = BinaryPrimitives.ReadUInt16LittleEndian(data[0..]),
            Okay = (data.Slice(2, 1)[0] != 0)
        };
    }
}

// ═══ Procedure: Vote (inputType=2) ═══

/// <summary>Input for procedure (empty payload).</summary>
public sealed class VotePayload : ITransactionPayload, ISmartContractInput
{
    public ushort InputType => 2;
    public ushort InputSize => 0;
    public int SerializedSize => 0;
    public byte[] GetPayloadBytes() => [];
    public byte[] ToBytes() => [];
}

/// <summary>Output (empty).</summary>
public readonly struct VoteOutput : ISmartContractOutput<VoteOutput>
{
    public static VoteOutput FromBytes(ReadOnlySpan<byte> data) => new();
}
