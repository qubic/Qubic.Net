// <auto-generated>
// Generated by Qubic.ContractGen from Quottery.h.
// Do not edit manually. Re-run the generator after updating deps/qubic-core.
// </auto-generated>

using System.Buffers.Binary;
using Qubic.Core.Contracts;
using Qubic.Core.Payloads;

namespace Qubic.Core.Contracts.Quottery;

/// <summary>Quottery contract (index 2).</summary>
public static class QuotteryContract
{
    /// <summary>Contract index on the Qubic network.</summary>
    public const int ContractIndex = 2;

    /// <summary>Gets the 32-byte contract public key.</summary>
    public static byte[] GetPublicKey() => QubicContracts.GetContractPublicKey(ContractIndex);

    /// <summary>Read-only query function IDs.</summary>
    public static class Functions
    {
        /// <summary>basicInfo (inputType=1).</summary>
        public const uint BasicInfo = 1;
        /// <summary>getBetInfo (inputType=2).</summary>
        public const uint GetBetInfo = 2;
        /// <summary>getBetOptionDetail (inputType=3).</summary>
        public const uint GetBetOptionDetail = 3;
        /// <summary>getActiveBet (inputType=4).</summary>
        public const uint GetActiveBet = 4;
        /// <summary>getBetByCreator (inputType=5).</summary>
        public const uint GetBetByCreator = 5;
    }

    /// <summary>State-mutating procedure IDs.</summary>
    public static class Procedures
    {
        /// <summary>issueBet (inputType=1).</summary>
        public const uint IssueBet = 1;
        /// <summary>joinBet (inputType=2).</summary>
        public const uint JoinBet = 2;
        /// <summary>cancelBet (inputType=3).</summary>
        public const uint CancelBet = 3;
        /// <summary>publishResult (inputType=4).</summary>
        public const uint PublishResult = 4;
    }
}

// ═══ Function: basicInfo (inputType=1) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct BasicInfoInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct BasicInfoOutput : ISmartContractOutput<BasicInfoOutput>
{
    public ulong FeePerSlotPerHour { get; init; }
    public ulong GameOperatorFee { get; init; }
    public ulong ShareholderFee { get; init; }
    public ulong MinBetSlotAmount { get; init; }
    public ulong BurnFee { get; init; }
    public uint NIssuedBet { get; init; }
    public ulong MoneyFlow { get; init; }
    public ulong MoneyFlowThroughIssueBet { get; init; }
    public ulong MoneyFlowThroughJoinBet { get; init; }
    public ulong MoneyFlowThroughFinalizeBet { get; init; }
    public ulong EarnedAmountForShareHolder { get; init; }
    public ulong PaidAmountForShareHolder { get; init; }
    public ulong EarnedAmountForBetWinner { get; init; }
    public ulong DistributedAmount { get; init; }
    public ulong BurnedAmount { get; init; }
    public byte[] GameOperator { get; init; }

    public static BasicInfoOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new BasicInfoOutput
        {
            FeePerSlotPerHour = BinaryPrimitives.ReadUInt64LittleEndian(data[0..]),
            GameOperatorFee = BinaryPrimitives.ReadUInt64LittleEndian(data[8..]),
            ShareholderFee = BinaryPrimitives.ReadUInt64LittleEndian(data[16..]),
            MinBetSlotAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[24..]),
            BurnFee = BinaryPrimitives.ReadUInt64LittleEndian(data[32..]),
            NIssuedBet = BinaryPrimitives.ReadUInt32LittleEndian(data[40..]),
            MoneyFlow = BinaryPrimitives.ReadUInt64LittleEndian(data[48..]),
            MoneyFlowThroughIssueBet = BinaryPrimitives.ReadUInt64LittleEndian(data[56..]),
            MoneyFlowThroughJoinBet = BinaryPrimitives.ReadUInt64LittleEndian(data[64..]),
            MoneyFlowThroughFinalizeBet = BinaryPrimitives.ReadUInt64LittleEndian(data[72..]),
            EarnedAmountForShareHolder = BinaryPrimitives.ReadUInt64LittleEndian(data[80..]),
            PaidAmountForShareHolder = BinaryPrimitives.ReadUInt64LittleEndian(data[88..]),
            EarnedAmountForBetWinner = BinaryPrimitives.ReadUInt64LittleEndian(data[96..]),
            DistributedAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[104..]),
            BurnedAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[112..]),
            GameOperator = data[120..].Slice(0, 32).ToArray()
        };
    }
}

// ═══ Function: getBetInfo (inputType=2) ═══

/// <summary>Input for query.</summary>
public readonly struct GetBetInfoInput : ISmartContractInput
{
    public const int Size = 4;

    public int SerializedSize => Size;

    public uint BetId { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), BetId);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetBetInfoOutput : ISmartContractOutput<GetBetInfoOutput>
{
    public uint BetId { get; init; }
    public uint NOption { get; init; }
    public byte[] Creator { get; init; }
    public byte[] BetDesc { get; init; }
    public byte[][] OptionDesc { get; init; }
    public byte[][] OracleProviderId { get; init; }
    public uint[] OracleFees { get; init; }
    public uint OpenDate { get; init; }
    public uint CloseDate { get; init; }
    public uint EndDate { get; init; }
    public ulong MinBetAmount { get; init; }
    public uint MaxBetSlotPerOption { get; init; }
    public uint[] CurrentBetState { get; init; }
    public sbyte[] BetResultWonOption { get; init; }
    public sbyte[] BetResultOPId { get; init; }

    public static GetBetInfoOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var optionDesc = new byte[8][];
        for (int i = 0; i < 8; i++)
        {
            optionDesc[i] = data[(72 + i * 32)..].Slice(0, 32).ToArray();
        }
        var oracleProviderId = new byte[8][];
        for (int i = 0; i < 8; i++)
        {
            oracleProviderId[i] = data[(328 + i * 32)..].Slice(0, 32).ToArray();
        }
        var oracleFees = new uint[8];
        for (int i = 0; i < 8; i++)
        {
            oracleFees[i] = BinaryPrimitives.ReadUInt32LittleEndian(data[(584 + i * 4)..]);
        }
        var currentBetState = new uint[8];
        for (int i = 0; i < 8; i++)
        {
            currentBetState[i] = BinaryPrimitives.ReadUInt32LittleEndian(data[(644 + i * 4)..]);
        }
        var betResultWonOption = new sbyte[8];
        for (int i = 0; i < 8; i++)
        {
            betResultWonOption[i] = (sbyte)data.Slice(676 + i * 1, 1)[0];
        }
        var betResultOPId = new sbyte[8];
        for (int i = 0; i < 8; i++)
        {
            betResultOPId[i] = (sbyte)data.Slice(684 + i * 1, 1)[0];
        }
        return new GetBetInfoOutput
        {
            BetId = BinaryPrimitives.ReadUInt32LittleEndian(data[0..]),
            NOption = BinaryPrimitives.ReadUInt32LittleEndian(data[4..]),
            Creator = data[8..].Slice(0, 32).ToArray(),
            BetDesc = data[40..].Slice(0, 32).ToArray(),
            OptionDesc = optionDesc,
            OracleProviderId = oracleProviderId,
            OracleFees = oracleFees,
            OpenDate = BinaryPrimitives.ReadUInt32LittleEndian(data[616..]),
            CloseDate = BinaryPrimitives.ReadUInt32LittleEndian(data[620..]),
            EndDate = BinaryPrimitives.ReadUInt32LittleEndian(data[624..]),
            MinBetAmount = BinaryPrimitives.ReadUInt64LittleEndian(data[632..]),
            MaxBetSlotPerOption = BinaryPrimitives.ReadUInt32LittleEndian(data[640..]),
            CurrentBetState = currentBetState,
            BetResultWonOption = betResultWonOption,
            BetResultOPId = betResultOPId
        };
    }
}

// ═══ Function: getBetOptionDetail (inputType=3) ═══

/// <summary>Input for query.</summary>
public readonly struct GetBetOptionDetailInput : ISmartContractInput
{
    public const int Size = 8;

    public int SerializedSize => Size;

    public uint BetId { get; init; }
    public uint BetOption { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), BetId);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(4), BetOption);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetBetOptionDetailOutput : ISmartContractOutput<GetBetOptionDetailOutput>
{
    public byte[][] Bettor { get; init; }

    public static GetBetOptionDetailOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var bettor = new byte[1024][];
        for (int i = 0; i < 1024; i++)
        {
            bettor[i] = data[(0 + i * 32)..].Slice(0, 32).ToArray();
        }
        return new GetBetOptionDetailOutput
        {
            Bettor = bettor
        };
    }
}

// ═══ Function: getActiveBet (inputType=4) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct GetActiveBetInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct GetActiveBetOutput : ISmartContractOutput<GetActiveBetOutput>
{
    public uint Count { get; init; }
    public uint[] ActiveBetId { get; init; }

    public static GetActiveBetOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var activeBetId = new uint[1024];
        for (int i = 0; i < 1024; i++)
        {
            activeBetId[i] = BinaryPrimitives.ReadUInt32LittleEndian(data[(4 + i * 4)..]);
        }
        return new GetActiveBetOutput
        {
            Count = BinaryPrimitives.ReadUInt32LittleEndian(data[0..]),
            ActiveBetId = activeBetId
        };
    }
}

// ═══ Function: getBetByCreator (inputType=5) ═══

/// <summary>Input for query.</summary>
public readonly struct GetBetByCreatorInput : ISmartContractInput
{
    public const int Size = 32;

    public int SerializedSize => Size;

    public required byte[] Creator { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Creator.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetBetByCreatorOutput : ISmartContractOutput<GetBetByCreatorOutput>
{
    public uint Count { get; init; }
    public uint[] BetId { get; init; }

    public static GetBetByCreatorOutput FromBytes(ReadOnlySpan<byte> data)
    {
        var betId = new uint[1024];
        for (int i = 0; i < 1024; i++)
        {
            betId[i] = BinaryPrimitives.ReadUInt32LittleEndian(data[(4 + i * 4)..]);
        }
        return new GetBetByCreatorOutput
        {
            Count = BinaryPrimitives.ReadUInt32LittleEndian(data[0..]),
            BetId = betId
        };
    }
}

// ═══ Procedure: issueBet (inputType=1) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class IssueBetPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 600;

    public ushort InputType => 1;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] BetDesc { get; init; }
    public required byte[][] OptionDesc { get; init; }
    public required byte[][] OracleProviderId { get; init; }
    public uint[] OracleFees { get; init; }
    public uint CloseDate { get; init; }
    public uint EndDate { get; init; }
    public ulong AmountPerSlot { get; init; }
    public uint MaxBetSlotPerOption { get; init; }
    public uint NumberOfOption { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BetDesc.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        for (int i = 0; i < 8 && OptionDesc != null && i < OptionDesc.Length; i++)
        {
            OptionDesc[i].AsSpan(0, 32).CopyTo(bytes.AsSpan(32 + i * 32));
        }
        for (int i = 0; i < 8 && OracleProviderId != null && i < OracleProviderId.Length; i++)
        {
            OracleProviderId[i].AsSpan(0, 32).CopyTo(bytes.AsSpan(288 + i * 32));
        }
        for (int i = 0; i < 8 && OracleFees != null && i < OracleFees.Length; i++)
        {
            BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(544 + i * 4), OracleFees[i]);
        }
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(576), CloseDate);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(580), EndDate);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(584), AmountPerSlot);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(592), MaxBetSlotPerOption);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(596), NumberOfOption);
        return bytes;
    }
}

/// <summary>Output (empty).</summary>
public readonly struct IssueBetOutput : ISmartContractOutput<IssueBetOutput>
{
    public static IssueBetOutput FromBytes(ReadOnlySpan<byte> data) => new();
}

// ═══ Procedure: joinBet (inputType=2) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class JoinBetPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 12;

    public ushort InputType => 2;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public uint BetId { get; init; }
    public uint NumberOfSlot { get; init; }
    public uint Option { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), BetId);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(4), NumberOfSlot);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(8), Option);
        return bytes;
    }
}

/// <summary>Output (empty).</summary>
public readonly struct JoinBetOutput : ISmartContractOutput<JoinBetOutput>
{
    public static JoinBetOutput FromBytes(ReadOnlySpan<byte> data) => new();
}

// ═══ Procedure: cancelBet (inputType=3) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class CancelBetPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 4;

    public ushort InputType => 3;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public uint BetId { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), BetId);
        return bytes;
    }
}

/// <summary>Output (empty).</summary>
public readonly struct CancelBetOutput : ISmartContractOutput<CancelBetOutput>
{
    public static CancelBetOutput FromBytes(ReadOnlySpan<byte> data) => new();
}

// ═══ Procedure: publishResult (inputType=4) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class PublishResultPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 8;

    public ushort InputType => 4;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public uint BetId { get; init; }
    public uint Option { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(0), BetId);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(4), Option);
        return bytes;
    }
}

/// <summary>Output (empty).</summary>
public readonly struct PublishResultOutput : ISmartContractOutput<PublishResultOutput>
{
    public static PublishResultOutput FromBytes(ReadOnlySpan<byte> data) => new();
}
