// <auto-generated>
// Generated by Qubic.ContractGen from Qswap.h.
// Do not edit manually. Re-run the generator after updating deps/qubic-core.
// </auto-generated>

using System.Buffers.Binary;
using Qubic.Core.Contracts;
using Qubic.Core.Payloads;

namespace Qubic.Core.Contracts.Qswap;

/// <summary>Qswap contract (index 13).</summary>
public static class QswapContract
{
    /// <summary>Contract index on the Qubic network.</summary>
    public const int ContractIndex = 13;

    /// <summary>Gets the 32-byte contract public key.</summary>
    public static byte[] GetPublicKey() => QubicContracts.GetContractPublicKey(ContractIndex);

    /// <summary>Read-only query function IDs.</summary>
    public static class Functions
    {
        /// <summary>Fees (inputType=1).</summary>
        public const uint Fees = 1;
        /// <summary>GetPoolBasicState (inputType=2).</summary>
        public const uint GetPoolBasicState = 2;
        /// <summary>GetLiquidityOf (inputType=3).</summary>
        public const uint GetLiquidityOf = 3;
        /// <summary>QuoteExactQuInput (inputType=4).</summary>
        public const uint QuoteExactQuInput = 4;
        /// <summary>QuoteExactQuOutput (inputType=5).</summary>
        public const uint QuoteExactQuOutput = 5;
        /// <summary>QuoteExactAssetInput (inputType=6).</summary>
        public const uint QuoteExactAssetInput = 6;
        /// <summary>QuoteExactAssetOutput (inputType=7).</summary>
        public const uint QuoteExactAssetOutput = 7;
        /// <summary>InvestRewardsInfo (inputType=8).</summary>
        public const uint InvestRewardsInfo = 8;
    }

    /// <summary>State-mutating procedure IDs.</summary>
    public static class Procedures
    {
        /// <summary>IssueAsset (inputType=1).</summary>
        public const uint IssueAsset = 1;
        /// <summary>TransferShareOwnershipAndPossession (inputType=2).</summary>
        public const uint TransferShareOwnershipAndPossession = 2;
        /// <summary>CreatePool (inputType=3).</summary>
        public const uint CreatePool = 3;
        /// <summary>AddLiquidity (inputType=4).</summary>
        public const uint AddLiquidity = 4;
        /// <summary>RemoveLiquidity (inputType=5).</summary>
        public const uint RemoveLiquidity = 5;
        /// <summary>SwapExactQuForAsset (inputType=6).</summary>
        public const uint SwapExactQuForAsset = 6;
        /// <summary>SwapQuForExactAsset (inputType=7).</summary>
        public const uint SwapQuForExactAsset = 7;
        /// <summary>SwapExactAssetForQu (inputType=8).</summary>
        public const uint SwapExactAssetForQu = 8;
        /// <summary>SwapAssetForExactQu (inputType=9).</summary>
        public const uint SwapAssetForExactQu = 9;
        /// <summary>SetInvestRewardsInfo (inputType=10).</summary>
        public const uint SetInvestRewardsInfo = 10;
        /// <summary>TransferShareManagementRights (inputType=11).</summary>
        public const uint TransferShareManagementRights = 11;
    }
}

// ═══ Function: Fees (inputType=1) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct FeesInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct FeesOutput : ISmartContractOutput<FeesOutput>
{
    public uint AssetIssuanceFee { get; init; }
    public uint PoolCreationFee { get; init; }
    public uint TransferFee { get; init; }
    public uint SwapFee { get; init; }
    public uint ShareholderFee { get; init; }
    public uint InvestRewardsFee { get; init; }
    public uint QxFee { get; init; }
    public uint BurnFee { get; init; }

    public static FeesOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new FeesOutput
        {
            AssetIssuanceFee = BinaryPrimitives.ReadUInt32LittleEndian(data[0..]),
            PoolCreationFee = BinaryPrimitives.ReadUInt32LittleEndian(data[4..]),
            TransferFee = BinaryPrimitives.ReadUInt32LittleEndian(data[8..]),
            SwapFee = BinaryPrimitives.ReadUInt32LittleEndian(data[12..]),
            ShareholderFee = BinaryPrimitives.ReadUInt32LittleEndian(data[16..]),
            InvestRewardsFee = BinaryPrimitives.ReadUInt32LittleEndian(data[20..]),
            QxFee = BinaryPrimitives.ReadUInt32LittleEndian(data[24..]),
            BurnFee = BinaryPrimitives.ReadUInt32LittleEndian(data[28..])
        };
    }
}

// ═══ Function: GetPoolBasicState (inputType=2) ═══

/// <summary>Input for query.</summary>
public readonly struct GetPoolBasicStateInput : ISmartContractInput
{
    public const int Size = 40;

    public int SerializedSize => Size;

    public required byte[] AssetIssuer { get; init; }
    public ulong AssetName { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        AssetIssuer.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(32), AssetName);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetPoolBasicStateOutput : ISmartContractOutput<GetPoolBasicStateOutput>
{
    public long PoolExists { get; init; }
    public long ReservedQuAmount { get; init; }
    public long ReservedAssetAmount { get; init; }
    public long TotalLiquidity { get; init; }

    public static GetPoolBasicStateOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetPoolBasicStateOutput
        {
            PoolExists = BinaryPrimitives.ReadInt64LittleEndian(data[0..]),
            ReservedQuAmount = BinaryPrimitives.ReadInt64LittleEndian(data[8..]),
            ReservedAssetAmount = BinaryPrimitives.ReadInt64LittleEndian(data[16..]),
            TotalLiquidity = BinaryPrimitives.ReadInt64LittleEndian(data[24..])
        };
    }
}

// ═══ Function: GetLiquidityOf (inputType=3) ═══

/// <summary>Input for query.</summary>
public readonly struct GetLiquidityOfInput : ISmartContractInput
{
    public const int Size = 72;

    public int SerializedSize => Size;

    public required byte[] AssetIssuer { get; init; }
    public ulong AssetName { get; init; }
    public required byte[] Account { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        AssetIssuer.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(32), AssetName);
        Account.AsSpan(0, 32).CopyTo(bytes.AsSpan(40));
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct GetLiquidityOfOutput : ISmartContractOutput<GetLiquidityOfOutput>
{
    public long Liquidity { get; init; }

    public static GetLiquidityOfOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new GetLiquidityOfOutput
        {
            Liquidity = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Function: QuoteExactQuInput (inputType=4) ═══

/// <summary>Input for query.</summary>
public readonly struct QuoteExactQuInputInput : ISmartContractInput
{
    public const int Size = 48;

    public int SerializedSize => Size;

    public required byte[] AssetIssuer { get; init; }
    public ulong AssetName { get; init; }
    public long QuAmountIn { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        AssetIssuer.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(32), AssetName);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(40), QuAmountIn);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct QuoteExactQuInputOutput : ISmartContractOutput<QuoteExactQuInputOutput>
{
    public long AssetAmountOut { get; init; }

    public static QuoteExactQuInputOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new QuoteExactQuInputOutput
        {
            AssetAmountOut = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Function: QuoteExactQuOutput (inputType=5) ═══

/// <summary>Input for query.</summary>
public readonly struct QuoteExactQuOutputInput : ISmartContractInput
{
    public const int Size = 48;

    public int SerializedSize => Size;

    public required byte[] AssetIssuer { get; init; }
    public ulong AssetName { get; init; }
    public long QuAmountOut { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        AssetIssuer.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(32), AssetName);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(40), QuAmountOut);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct QuoteExactQuOutputOutput : ISmartContractOutput<QuoteExactQuOutputOutput>
{
    public long AssetAmountIn { get; init; }

    public static QuoteExactQuOutputOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new QuoteExactQuOutputOutput
        {
            AssetAmountIn = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Function: QuoteExactAssetInput (inputType=6) ═══

/// <summary>Input for query.</summary>
public readonly struct QuoteExactAssetInputInput : ISmartContractInput
{
    public const int Size = 48;

    public int SerializedSize => Size;

    public required byte[] AssetIssuer { get; init; }
    public ulong AssetName { get; init; }
    public long AssetAmountIn { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        AssetIssuer.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(32), AssetName);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(40), AssetAmountIn);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct QuoteExactAssetInputOutput : ISmartContractOutput<QuoteExactAssetInputOutput>
{
    public long QuAmountOut { get; init; }

    public static QuoteExactAssetInputOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new QuoteExactAssetInputOutput
        {
            QuAmountOut = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Function: QuoteExactAssetOutput (inputType=7) ═══

/// <summary>Input for query.</summary>
public readonly struct QuoteExactAssetOutputInput : ISmartContractInput
{
    public const int Size = 48;

    public int SerializedSize => Size;

    public required byte[] AssetIssuer { get; init; }
    public ulong AssetName { get; init; }
    public long AssetAmountOut { get; init; }

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        AssetIssuer.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(32), AssetName);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(40), AssetAmountOut);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct QuoteExactAssetOutputOutput : ISmartContractOutput<QuoteExactAssetOutputOutput>
{
    public long QuAmountIn { get; init; }

    public static QuoteExactAssetOutputOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new QuoteExactAssetOutputOutput
        {
            QuAmountIn = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Function: InvestRewardsInfo (inputType=8) ═══

/// <summary>Input for query (empty).</summary>
public readonly struct InvestRewardsInfoInput : ISmartContractInput
{
    public int SerializedSize => 0;
    public byte[] ToBytes() => [];
}

/// <summary>Output.</summary>
public readonly struct InvestRewardsInfoOutput : ISmartContractOutput<InvestRewardsInfoOutput>
{
    public uint InvestRewardsFee { get; init; }
    public byte[] InvestRewardsId { get; init; }

    public static InvestRewardsInfoOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new InvestRewardsInfoOutput
        {
            InvestRewardsFee = BinaryPrimitives.ReadUInt32LittleEndian(data[0..]),
            InvestRewardsId = data[8..].Slice(0, 32).ToArray()
        };
    }
}

// ═══ Procedure: IssueAsset (inputType=1) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class IssueAssetPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 32;

    public ushort InputType => 1;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public ulong AssetName { get; init; }
    public long NumberOfShares { get; init; }
    public ulong UnitOfMeasurement { get; init; }
    public sbyte NumberOfDecimalPlaces { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(0), AssetName);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(8), NumberOfShares);
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(16), UnitOfMeasurement);
        bytes.AsSpan(24, 1)[0] = (byte)NumberOfDecimalPlaces;
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct IssueAssetOutput : ISmartContractOutput<IssueAssetOutput>
{
    public long IssuedNumberOfShares { get; init; }

    public static IssueAssetOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new IssueAssetOutput
        {
            IssuedNumberOfShares = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: TransferShareOwnershipAndPossession (inputType=2) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class TransferShareOwnershipAndPossessionPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 80;

    public ushort InputType => 2;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] AssetIssuer { get; init; }
    public ulong AssetName { get; init; }
    public required byte[] NewOwnerAndPossessor { get; init; }
    public long Amount { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        AssetIssuer.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(32), AssetName);
        NewOwnerAndPossessor.AsSpan(0, 32).CopyTo(bytes.AsSpan(40));
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(72), Amount);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct TransferShareOwnershipAndPossessionOutput : ISmartContractOutput<TransferShareOwnershipAndPossessionOutput>
{
    public long TransferredAmount { get; init; }

    public static TransferShareOwnershipAndPossessionOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new TransferShareOwnershipAndPossessionOutput
        {
            TransferredAmount = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: CreatePool (inputType=3) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class CreatePoolPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 40;

    public ushort InputType => 3;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] AssetIssuer { get; init; }
    public ulong AssetName { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        AssetIssuer.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(32), AssetName);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct CreatePoolOutput : ISmartContractOutput<CreatePoolOutput>
{
    public bool Success { get; init; }

    public static CreatePoolOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new CreatePoolOutput
        {
            Success = (data.Slice(0, 1)[0] != 0)
        };
    }
}

// ═══ Procedure: AddLiquidity (inputType=4) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class AddLiquidityPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 64;

    public ushort InputType => 4;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] AssetIssuer { get; init; }
    public ulong AssetName { get; init; }
    public long AssetAmountDesired { get; init; }
    public long QuAmountMin { get; init; }
    public long AssetAmountMin { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        AssetIssuer.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(32), AssetName);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(40), AssetAmountDesired);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(48), QuAmountMin);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(56), AssetAmountMin);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct AddLiquidityOutput : ISmartContractOutput<AddLiquidityOutput>
{
    public long UserIncreaseLiquidity { get; init; }
    public long QuAmount { get; init; }
    public long AssetAmount { get; init; }

    public static AddLiquidityOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new AddLiquidityOutput
        {
            UserIncreaseLiquidity = BinaryPrimitives.ReadInt64LittleEndian(data[0..]),
            QuAmount = BinaryPrimitives.ReadInt64LittleEndian(data[8..]),
            AssetAmount = BinaryPrimitives.ReadInt64LittleEndian(data[16..])
        };
    }
}

// ═══ Procedure: RemoveLiquidity (inputType=5) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class RemoveLiquidityPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 64;

    public ushort InputType => 5;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] AssetIssuer { get; init; }
    public ulong AssetName { get; init; }
    public long BurnLiquidity { get; init; }
    public long QuAmountMin { get; init; }
    public long AssetAmountMin { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        AssetIssuer.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(32), AssetName);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(40), BurnLiquidity);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(48), QuAmountMin);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(56), AssetAmountMin);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct RemoveLiquidityOutput : ISmartContractOutput<RemoveLiquidityOutput>
{
    public long QuAmount { get; init; }
    public long AssetAmount { get; init; }

    public static RemoveLiquidityOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new RemoveLiquidityOutput
        {
            QuAmount = BinaryPrimitives.ReadInt64LittleEndian(data[0..]),
            AssetAmount = BinaryPrimitives.ReadInt64LittleEndian(data[8..])
        };
    }
}

// ═══ Procedure: SwapExactQuForAsset (inputType=6) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class SwapExactQuForAssetPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 48;

    public ushort InputType => 6;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] AssetIssuer { get; init; }
    public ulong AssetName { get; init; }
    public long AssetAmountOutMin { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        AssetIssuer.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(32), AssetName);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(40), AssetAmountOutMin);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct SwapExactQuForAssetOutput : ISmartContractOutput<SwapExactQuForAssetOutput>
{
    public long AssetAmountOut { get; init; }

    public static SwapExactQuForAssetOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new SwapExactQuForAssetOutput
        {
            AssetAmountOut = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: SwapQuForExactAsset (inputType=7) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class SwapQuForExactAssetPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 48;

    public ushort InputType => 7;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] AssetIssuer { get; init; }
    public ulong AssetName { get; init; }
    public long AssetAmountOut { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        AssetIssuer.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(32), AssetName);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(40), AssetAmountOut);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct SwapQuForExactAssetOutput : ISmartContractOutput<SwapQuForExactAssetOutput>
{
    public long QuAmountIn { get; init; }

    public static SwapQuForExactAssetOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new SwapQuForExactAssetOutput
        {
            QuAmountIn = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: SwapExactAssetForQu (inputType=8) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class SwapExactAssetForQuPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 56;

    public ushort InputType => 8;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] AssetIssuer { get; init; }
    public ulong AssetName { get; init; }
    public long AssetAmountIn { get; init; }
    public long QuAmountOutMin { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        AssetIssuer.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(32), AssetName);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(40), AssetAmountIn);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(48), QuAmountOutMin);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct SwapExactAssetForQuOutput : ISmartContractOutput<SwapExactAssetForQuOutput>
{
    public long QuAmountOut { get; init; }

    public static SwapExactAssetForQuOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new SwapExactAssetForQuOutput
        {
            QuAmountOut = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: SwapAssetForExactQu (inputType=9) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class SwapAssetForExactQuPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 56;

    public ushort InputType => 9;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] AssetIssuer { get; init; }
    public ulong AssetName { get; init; }
    public long AssetAmountInMax { get; init; }
    public long QuAmountOut { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        AssetIssuer.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteUInt64LittleEndian(bytes.AsSpan(32), AssetName);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(40), AssetAmountInMax);
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(48), QuAmountOut);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct SwapAssetForExactQuOutput : ISmartContractOutput<SwapAssetForExactQuOutput>
{
    public long AssetAmountIn { get; init; }

    public static SwapAssetForExactQuOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new SwapAssetForExactQuOutput
        {
            AssetAmountIn = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}

// ═══ Procedure: SetInvestRewardsInfo (inputType=10) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class SetInvestRewardsInfoPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 32;

    public ushort InputType => 10;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required byte[] NewInvestRewardsId { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        NewInvestRewardsId.AsSpan(0, 32).CopyTo(bytes.AsSpan(0));
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct SetInvestRewardsInfoOutput : ISmartContractOutput<SetInvestRewardsInfoOutput>
{
    public bool Success { get; init; }

    public static SetInvestRewardsInfoOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new SetInvestRewardsInfoOutput
        {
            Success = (data.Slice(0, 1)[0] != 0)
        };
    }
}

// ═══ Procedure: TransferShareManagementRights (inputType=11) ═══

/// <summary>Input payload for procedure.</summary>
public sealed class TransferShareManagementRightsPayload : ITransactionPayload, ISmartContractInput
{
    public const int Size = 56;

    public ushort InputType => 11;
    public ushort InputSize => Size;
    public int SerializedSize => Size;

    public required QubicAsset Asset { get; init; }
    public long NumberOfShares { get; init; }
    public uint NewManagingContractIndex { get; init; }

    public byte[] GetPayloadBytes() => ToBytes();

    public byte[] ToBytes()
    {
        var bytes = new byte[Size];
        Asset.WriteTo(bytes.AsSpan(0));
        BinaryPrimitives.WriteInt64LittleEndian(bytes.AsSpan(40), NumberOfShares);
        BinaryPrimitives.WriteUInt32LittleEndian(bytes.AsSpan(48), NewManagingContractIndex);
        return bytes;
    }
}

/// <summary>Output.</summary>
public readonly struct TransferShareManagementRightsOutput : ISmartContractOutput<TransferShareManagementRightsOutput>
{
    public long TransferredNumberOfShares { get; init; }

    public static TransferShareManagementRightsOutput FromBytes(ReadOnlySpan<byte> data)
    {
        return new TransferShareManagementRightsOutput
        {
            TransferredNumberOfShares = BinaryPrimitives.ReadInt64LittleEndian(data[0..])
        };
    }
}
